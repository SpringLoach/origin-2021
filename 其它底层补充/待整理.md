#### jquery部分方法  

方法 | 说明
:-: | :-: 
removeClass(*class*) | 从元素移除一个或多个类
toggleClass(*class*) | 切换类：存在删，不存在添
addClass(*class*) | 添加指定的类
siblings() | 获得匹配元素集合中所有元素的同辈元素
next() | 获得匹配元素集合中每个元素紧邻的同辈元素
find() | 获得当前匹配元素集合中每个元素的后代

----

判断 | JavaScript是 | 说明
:-: | :-: | :-: 
× | 面向对象的程序设计语言 | 基于面向对象
√ | 解释性语言 | 相对于编译

#### 原型  
> 通过 `new function(){}` 返回的是一个继承自 Object 的实例对象，没有继承 Function。  

```
Object.prototype.a = function(){};
Function.prototype.b = function(){};
var f = new function(){};
var f1 = new Function

console.log(f.a);   // ƒ (){}
console.log(f.b);   // undefined
console.log(f1.a);  // ƒ (){}
console.log(f1.b);  // ƒ (){}
```

原型查找  
> 由于 b 自身没有 x，`b.x` 的值会顺着原型链往上找，由于它的原型实例存在一个未赋值的 `x`，故为 `undefined`。  
> 
> 若将 ① 删除，结果为 1。若将 ② 传入任意参数，结果为该参数。   

```
function A(x){
  this.x = x;       // ①
}
A.prototype.x = 1;

function B(x){
this.x = x;
}
B.prototype = new A();   // ②
var a = new A(2), b = new B(3);
delete b.x;    

console.log(a.x);  //  2
console.log(b.x);  //  undefined
```

判断 | 触发隐式转换 | 说明
:-: | :-: | :-: 
× | 2e1 * 0xaa | 无类型转换  
√ | parseInt(12.34, 10) | 解析字符串并返回整数  

判断 | 正确添加样式 | 说明
:-: | :-: | :-: 
√ | 每个对象都具有一个名为__proto__的属性 | 隐式原型(null无)
× | 每个对象都具有一个名为prototype的方法 | /
√ | 每个对象的__proto__属性指向自身构造函数的prototype | /
√ | 对象不具有prototype属性，只有函数才有prototype属性 | 显式原型

#### DOM  

判断 | 正确添加样式
:-: | :-:
√ | document.getElementById('button1').style.backgroundColor="red";
× | document.getElementById('button1').style.backGroundColor="red"; 

#### 提升顺序  
> 函数提升优先级高于变量提升。  
> 
> 相同作用域时声明变量而不赋值则还是以前的值。  

```
console.log(foo);
var foo = 1         //变量提升
console.log(foo)
foo()
function foo(){     //函数提升
   console.log('函数')
}
```
等价于
```
function foo(){
   console.log('函数')
}
var foo 

console.log(foo) // foo() {}
foo = 1; 
console.log(foo) // 1
foo()            // 报错
```

**栗子2**  
> 函数表达式不能被提前。  
```
var x = foo();
var foo = function foo() {...}
```
等价于
```
var foo;
var x = foo();
foo = function foo() {...}
```

**栗子3**  
> 由于声明被提升，函数作用域中的 `b` 不会影响全局。  

```
var b = 3;
(function(){
  b = 5;
  var b = 2;
})();
console.log(b);  // 3
```

#### 异步编程  

会报错，因为排除的拒绝期约没有被捕获。  
```
Promise.reject(123).finally(a => {
  console.log(a);
});
```

#### 判断关系  

判断 | 表达式
:-: | :-: 
× | undefined == 0
× | null == false
√ | null == undefined

#### 表单  

下拉菜单中，用户更改表单元素Select中的值时，调用的事件处理程序

判断 | 事件处理程序 | 时机
:-: | :-:  | :-: 
√ | onMouseOver | 鼠标指针移动到元素上
√ | onFocus  | 获取焦点
√ | onChange | 元素值改变时触发
√ | onClick | / 

#### 鼠标事件  

事件 | 时机
:-:  | :-: 
click | 点击
contextmenu | 鼠标右键、键盘按键触发菜单
mouseout | 鼠标移出元素

#### 改变函数作用域  
> this 绑定的优先级是 new>bind>call(apply)>obj.func()>默认绑定  
> 
> 尽管上下文中的 `this` 实际上指代的是 console，但打印的 `this` 是从外部传入的。  

```
var obj = {};
obj.log = console.log;
obj.log.call(console,this);  // Window
```

#### 正则表达式   
> 只能输入零和非零开头的数字。  

```
^(0|[1-9][0-9]*)$

^   以。。。开头; $  以。。。结尾。
*   任意多次
|   或
（）组
[]  集合
```

#### 暂时性死区  
> 虽然无法提升，但 JS 引擎会注意到后面 let 的**定义**，与此同时，**就不能**去取外层的同名变量了。  

```
let x = 10;
let foo = () => {
  console.log(x);
  let x = 20;
  x++;
}

foo();  // 报错
```

#### 最准确判断数组类型

判断 | 事件处理程序 | 说明 
:-: | :-: | :-:  
× | `arr instanceof Array` | 跨框架不行
√ | `Object.prototype.toString.call(arr) === '[object Array]'` | isArray的实现原理，不用数组被改写的toString

#### 运算优先级  
> `+` 运算符的优先级高于三目运算符。  

```
var val;
console.log('Value is ' + (val != '0') ? 'define' : 'undefine');
```

#### 隐形转换  

```
let a = 2.2;
console.log(a.split('.')[0]);  // 报错
```

#### History对象  
> History 对象包含用户（在浏览器窗口中）访问过的 URL
> 
> 但出于隐私方面的原因，History 对象不再允许脚本访问已经访问过的实际 URL。唯一保持使用的功能只有 back()、forward() 和 go() 方法。  





```

```



