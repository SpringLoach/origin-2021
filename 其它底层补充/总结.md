**对于不同身份，如管理者和用户，如何为其展示不同的页面。**   

1. 用户登录后，在后台判断其身份，并将该信息返回给前端。  
2. 前端可以根据该信息，决定具体要跳转的路径。   
3. 或者根据该信息，决定是否禁用某些功能，是否渲染页面的某些部分。  
4. 为了防止用户直接通过路径访问无权限的页面。在路由守卫中，验证该信息，如果信息不符合要求，就强制跳转到登录页或其它页面。  

**对于用户上传的大体积图片，进行压缩**    

1. 脚本之家，提供的一个较清晰的[思路](https://www.jb51.net/article/182078.htm)。    
2. 另一篇博客，还涉及到了图片预览的[功能](https://blog.csdn.net/lgno2/article/details/109446279)。

大概流程  

- 通过原生的input标签拿到要上传的图片文件  
- 将图片文件转化成img标签（HTMLImageElement）  
- 在canvas上**压缩绘制**该img标签  
- 将canvas绘制的图像转成blob文件  
- 最后将该blob文件传到服务端  

```
/* HTML */
<input type="file" accept="image/*" onchange="getFile(event)" />

<script>
function getFile(event) {
  console.log(event.target.files);
   
  // ② 读取文件转成img标签元素
  // ③ 取出该元素的宽高度，定义一个最大限度的宽高度，如果超过这个限制宽高度，则进行等比例的缩放
  // ④ 创建画布并将img绘制到画布上
  // ⑤ 实际上不需要的步骤，用于查看效果
  // ⑥ 转成blob文件
  // ⑦ 首参即需要的blob，将其上传
  
  console.log(img);
}

</script>
```
> 由于这中间存在不少异步回调操作，故可以另行将其整理起来。  

②
```
  const img = new Image()
  const reader = new FileReader()
  
  // 用来读取File对象或Blob对象，这里读取File
  reader.readAsDataURL(event.target.files[0]) 
     
  // result返回 DataURL 格式（Base64 编码）的字符串，代表图片内容   
  reader.onload = function(e){ 
   img.src = e.target.result
   // ③ ④ ⑤ ⑥ ⑦
  }
```

③
```
const { width: originWidth, height: originHeight } = img
// 最大尺寸限制
const maxWidth = 1000,maxHeight = 1000
// 需要压缩的目标尺寸
let targetWidth = originWidth, targetHeight = originHeight
// 等比例计算超过最大限制时缩放后的图片尺寸
if (originWidth > maxWidth || originHeight > maxHeight) {
  if (originWidth / originHeight > 1) {
   // 宽图片
   targetWidth = maxWidth
   targetHeight = Math.round(maxWidth * (originHeight / originWidth))
  } else {
   // 高图片
   targetHeight = maxHeight
   targetWidth = Math.round(maxHeight * (originWidth / originHeight))
  }
 }
```

④⑤⑥⑦
```
// ④ 创建画布并将img绘制到画布上
const canvas = document.createElement('canvas')

// ⑤ 实际上不需要的一步，用于查看效果
document.body.appendChild(canvas);

const context = canvas.getContext('2d')
 
// 设置宽高度为等同于要压缩图片的尺寸
canvas.width = targetWidth
canvas.height = targetHeight
 
context.clearRect(0, 0, targetWidth, targetHeight)
// 分别是元素、区域初始位置和区域宽高
// 将 img 绘制到画布上
context.drawImage(img, 0, 0, targetWidth, targetHeight)

 // ⑥ 转成blob文件
 canvas.toBlob(data => {
   ⑦ 首参即需要的blob，在这将其上传
   console.log(data);
 });
}
```

关于转成blob文件  
> 将canvas转换为文件的方法。  

参数 | 性质 | 说明 | 默认值
:-: | :-: | :- | :-:
callback | 必选 | 回调函数，首参为转化后的blob文件 | /
type | 可选 | **要转成**的图片类型 | `image/png`
encoderOptions | 可选 | 值在0与1之间，当格式为 `image/jpeg` 或 `image/webp` 时指定图片展示质量 | /

```
canvas.toBlob(callback, type, encoderOptions);
```

**如何进行类型判断**  

1. 使用 `typeof` 关键字可以判断 null 以外的原始类型，它会将 null、数组、日期对象都返回为 `Object`。    
2. 故对于对象的正确类型，要使用 `instanceof` 进行判断，它内部机制是通过原型链来判断的。但它不能判断原始类型。  

**说说this的指向**  

1. 首先，判断函数的类型。  
2. 如果是箭头函数，那 `this` 将指向包裹箭头函数的第一个普通函数的 `this`。（定义环境）  
3. 如果是通过 `bind`、`call`、`apply`这些方式调用，那么 `this` 指向第一个参数或者 Window。  
4. 如果是普通函数，且通过 `new` 调用，那么 `this` 指向实例。  
5. 作为直接调用的函数，指向 Window。 `foo()` 
6. 被对象调用时，指向该对象。 `obj.foo()` 

**如何理解闭包**  

1. 指引用了另一个函数作用域中变量的函数，通常在嵌套函数中实现。  
2. 正常来说，一个函数执行完毕后，局部活动对象就会被销毁。  
3. 但是对于闭包，由于存在对包含函数活动对象的引用，使它不能被正常销毁。  
4. 这个技术通常用于设置私有变量，并对其进行仅一次的初始赋值。
5. 比如定时器、防抖节流函数，都会应用到它。  

**循环中使用闭包解决 var 定义函数的问题**  

```
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
} 
```  

1. 可以用 `let` 代替 var`，形成块作用域  
2. 将输出值作为定时函数的第三个参数传入，保存到参数作用域    
3. 在循环内部使用闭包，使值得以依次传入  


























