**对于不同身份，如管理者和用户，如何为其展示不同的页面。**   

1. 用户登录后，在后台判断其身份，并将该信息返回给前端。  
2. 前端可以根据该信息，决定具体要跳转的路径。   
3. 或者根据该信息，决定是否禁用某些功能，是否渲染页面的某些部分。  
4. 为了防止用户直接通过路径访问无权限的页面。在路由守卫中，验证该信息，如果信息不符合要求，就强制跳转到登录页或其它页面。  

**对于用户上传的大体积图片，进行压缩**    

1. 脚本之家，提供的一个较清晰的[思路](https://www.jb51.net/article/182078.htm)。    
2. 另一篇博客，还涉及到了图片预览的[功能](https://blog.csdn.net/lgno2/article/details/109446279)。

大概流程  

- 通过原生的input标签拿到要上传的图片文件  
- 将图片文件转化成img标签（HTMLImageElement）  
- 在canvas上**压缩绘制**该img标签  
- 将canvas绘制的图像转成blob文件  
- 最后将该blob文件传到服务端  

```
/* HTML */
<input type="file" accept="image/*" onchange="getFile(event)" />

<script>
function getFile(event) {
  console.log(event.target.files);
   
  // ② 读取文件转成img标签元素
  // ③ 取出该元素的宽高度，定义一个最大限度的宽高度，如果超过这个限制宽高度，则进行等比例的缩放
  // ④ 创建画布并将img绘制到画布上
  // ⑤ 实际上不需要的步骤，用于查看效果
  // ⑥ 转成blob文件
  // ⑦ 首参即需要的blob，将其上传
  
  console.log(img);
}

</script>
```
> 由于这中间存在不少异步回调操作，故可以另行将其整理起来。  

②
```
  const img = new Image()
  const reader = new FileReader()
  
  // 用来读取File对象或Blob对象，这里读取File
  reader.readAsDataURL(event.target.files[0]) 
     
  // result返回 DataURL 格式（Base64 编码）的字符串，代表图片内容   
  reader.onload = function(e){ 
   img.src = e.target.result
   // ③ ④ ⑤ ⑥ ⑦
  }
```

③
```
const { width: originWidth, height: originHeight } = img
// 最大尺寸限制
const maxWidth = 1000,maxHeight = 1000
// 需要压缩的目标尺寸
let targetWidth = originWidth, targetHeight = originHeight
// 等比例计算超过最大限制时缩放后的图片尺寸
if (originWidth > maxWidth || originHeight > maxHeight) {
  if (originWidth / originHeight > 1) {
   // 宽图片
   targetWidth = maxWidth
   targetHeight = Math.round(maxWidth * (originHeight / originWidth))
  } else {
   // 高图片
   targetHeight = maxHeight
   targetWidth = Math.round(maxHeight * (originWidth / originHeight))
  }
 }
```

④⑤⑥⑦
```
// ④ 创建画布并将img绘制到画布上
const canvas = document.createElement('canvas')

// ⑤ 实际上不需要的一步，用于查看效果
document.body.appendChild(canvas);

const context = canvas.getContext('2d')
 
// 设置宽高度为等同于要压缩图片的尺寸
canvas.width = targetWidth
canvas.height = targetHeight
 
context.clearRect(0, 0, targetWidth, targetHeight)
// 分别是元素、区域初始位置和区域宽高
// 将 img 绘制到画布上
context.drawImage(img, 0, 0, targetWidth, targetHeight)

 // ⑥ 转成blob文件
 canvas.toBlob(data => {
   ⑦ 首参即需要的blob，在这将其上传
   console.log(data);
 });
}
```

关于转成blob文件  
> 将canvas转换为文件的方法。  

参数 | 性质 | 说明 | 默认值
:-: | :-: | :- | :-:
callback | 必选 | 回调函数，首参为转化后的blob文件 | /
type | 可选 | **要转成**的图片类型 | `image/png`
encoderOptions | 可选 | 值在0与1之间，当格式为 `image/jpeg` 或 `image/webp` 时指定图片展示质量 | /

```
canvas.toBlob(callback, type, encoderOptions);
```

**项目中有哪些地方用到了模块化？**  

1. 比如首页，就包括了顶部栏、轮播图、分类导航栏、宝贝展示、回到顶部等组件。  
2. 每个子组件的功能、布局，都由该组件内部实现，减少与首页组件的耦合性。  
3. 对于顶部栏、底部导航栏这些在很多视图都会用到的东西，也会将它抽离成组件。  
4. 像商品详情页，把它抽离成组件后，对于不同宝贝只要传入不同数据即可，提高了代码的复用性和可维护性。  

**如何进行类型判断**  

1. 使用 `typeof` 关键字可以判断 null 以外的原始类型，它会将 null、数组、日期对象都返回为 `Object`。    
2. 故对于对象的正确类型，要使用 `instanceof` 进行判断，它内部机制是通过原型链来判断的。但它不能判断原始类型。  

**说说this的指向**  

1. 首先，判断函数的类型。  
2. 如果是箭头函数，那 `this` 将指向包裹箭头函数的第一个普通函数的 `this`。（定义环境）  
3. 如果是通过 `bind`、`call`、`apply`这些方式调用，那么 `this` 指向第一个参数或者 Window。  
4. 如果是普通函数，且通过 `new` 调用，那么 `this` 指向实例。  
5. 作为直接调用的函数，指向 Window。 `foo()` 
6. 被对象调用时，指向该对象。 `obj.foo()` 

**如何理解闭包**  

1. 指引用了另一个函数作用域中变量的函数，通常在嵌套函数中实现。  
2. 正常来说，一个函数执行完毕后，局部活动对象就会被销毁。  
3. 但是对于闭包，由于存在对包含函数活动对象的引用，使它不能被正常销毁。  
4. 这个技术通常用于设置私有变量，并对其进行仅一次的初始赋值。
5. 比如定时器、防抖节流函数，都会应用到它。  

**循环中使用闭包解决 var 定义函数的问题**  

```
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
} 
```  

1. 可以用 `let` 代替 var`，形成块作用域  
2. 将输出值作为定时函数的第三个参数传入，保存到参数作用域    
3. 在循环内部使用闭包，使值得以依次传入  

**深浅拷贝**  
> [跳转](https://github.com/SpringLoach/origin-2021/blob/happy-day/其它底层补充/高频知识点.md#深浅拷贝)。  

**如何理解原型链**  

1. 原型链就是多个对象通过 `__proto__` 的方式连接了起来。  
2. 在对象上获取某个属性时，如果实例没有，就会通过原型链往上找。  
3. 函数拥有 `prototype` 属性，在被当作构造函数使用时，与创建出来的实例对象的 `__proto__` 相同。  
4. `prototype` 即原型对象，有自己的 `__proto__` 和 `construcotr`。  
5. 正常的原型链都会终止于 `Object.prototype`。  

```
function c() {}
let x = new c

console.log(c.prototype === x.__proto__);  // true
console.log(x.__proto__.__proto__ === Object.prototype);  // true
console.log(c.__proto__ === Function.prototype);  // true
```

**var、let及const的区别**  
> [跳转](https://github.com/SpringLoach/origin-2021/blob/happy-day/其它底层补充/高频知识点.md#varlet及const的区别)

**了解过原型继承和Class继承么**
 
1. 先说一下组合继承。它综合了原型链和盗用继承，通过在子类中使用call调用父类这个构造函数，并改变它的上下文来获取属性。  
2. 然后将父类的实例作为子类原型，以继承函数。  
3. 优点在于可向构造函数传参，且与父类的引用属性不会共享。  
4. 但由于调用了父类这个构造函数，造成子类原型上有不需要的父类属性，浪费内存。  
5. 寄生组合继承，会将父类的原型作为子类原型来继承函数，避免了这个问题。  
6. 但它需要注意将子类原型上的构造函数指向子类自身。  
7. 对于 `Class`，其实 `JS` 中没有真正的类，`Class` 只是 ES6 新增的语法糖，本质还是函数。 
8. class 实现继承的核心在于使用 `extends` 表明继承自哪个父类，并且在子类构造函数中必须调用 `super`，可以看成 `Parent.call(this, value)`。  

**为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？**  

1. 使用模块化可以解决命名冲突的问题，并能够提高代码的复用性和可维护性。  

2. 以前是通过立即执行函数来实现模块化的，通过函数作用域去解决命名冲突、污染全局作用域的问题。  

3. AMD 和 CMD 现在已经很少使用。  

4. CommonJS。最早是 Node 在使用，在 Webpack 中就能见到它。

5. ES Module。与 CommonJS 不同，ES Module 导入的是拷贝值，不会因为导出值的改变而更新。

**进程与线程区别？JS 单线程带来的好处？**   

1. 进程是 cpu 资源分配的[最小单位](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/底层原理.md#区分进程与线程)。  
2. 线程是 cpu 调度的最小单位，一个进程里可以有一到多个线程。  
3. 打开一个标签页时，通常就创建了一个进程，并且内部存在渲染线程、JS引擎线程、请求线程等。  
4. 作为浏览器脚本语言，JS 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。如果 JS 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器就不知道以哪个线程为准了。  

**什么是执行栈？**  

1. 可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。  
2. 使用嵌套函数的时候，会将内部函数调用弹出后，再弹出外部函数。  
3. 所以对于递归，要注意提供一个基线条件，否则会导致栈溢出。  

**异步代码执行顺序？解释一下什么是 Event Loop ？**  

1. 先说一下宏任务和微任务。  
2. 每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调**并放到执行栈中**执行）。
3. 它包括整体代码、setTimeout、setInterval、I/O、UI交互事件。  
4. 在当前宏任务执行结束后立即执行的任务就是微任务，比如Promise.then。  
5. 事件循环的过程，首先会执行整体代码，其中遇到的异步代码会分配给专门的线程去执行，完成相应条件后添加到消息队列。  
6. 然后会将所有的微任务执行，此后 JS 引擎线程停止，交由 GUI 渲染线程负责渲染页面。  
7. 再从消息队列中获取一个事件回调并放到执行栈中，作为宏任务开始执行。  

**为什么0.1+0.2!=0.3？**  
> [跳转](https://github.com/SpringLoach/origin-2021/blob/happy-day/其它底层补充/高频知识点.md#为什么010203)。  

**了解事件代理吗？**  

- 如果一个节点中的子节点是动态生成的，这种情况下，会将子节点需要注册事件的话应该注册在父节点上。  
- 这样做可以节省内存，并且不需要给子节点注销事件。  

**什么是跨域？为什么浏览器要使用同源策略？**   
> [跳转](https://github.com/SpringLoach/origin-2021/blob/happy-day/其它底层补充/高频知识点.md#跨域)。

**了解哪些解决跨域方案**  
> [跳转](https://github.com/SpringLoach/origin-2021/blob/happy-day/其它底层补充/高频知识点.md#跨域)。

































