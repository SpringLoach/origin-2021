**对于不同身份，如管理者和用户，如何为其展示不同的页面。**   

1. 用户登录后，在后台判断其身份，并将该信息返回给前端。  
2. 前端可以根据该信息，决定具体要跳转的路径。   
3. 或者根据该信息，决定是否禁用某些功能，是否渲染页面的某些部分。  
4. 为了防止用户直接通过路径访问无权限的页面。在路由守卫中，验证该信息，如果信息不符合要求，就强制跳转到登录页或其它页面。  

**对于用户上传的大体积图片，进行压缩**    

1. 脚本之家，提供的一个较清晰的[思路](https://www.jb51.net/article/182078.htm)。    
2. 另一篇博客，还涉及到了图片预览的[功能](https://blog.csdn.net/lgno2/article/details/109446279)。

大概流程  

- 通过原生的input标签拿到要上传的图片文件  
- 将图片文件转化成img标签（HTMLImageElement）  
- 在canvas上**压缩绘制**该img标签  
- 将canvas绘制的图像转成blob文件  
- 最后将该blob文件传到服务端  

```
/* HTML */
<input type="file" accept="image/*" onchange="getFile(event)" />

<script>
function getFile(event) {
  console.log(event.target.files);
   
  // ② 读取文件转成img标签元素
  // ③ 取出该元素的宽高度，定义一个最大限度的宽高度，如果超过这个限制宽高度，则进行等比例的缩放
  // ④ 创建画布并将img绘制到画布上
  // ⑤ 实际上不需要的步骤，用于查看效果
  // ⑥ 转成blob文件
  // ⑦ 首参即需要的blob，将其上传
  
  console.log(img);
}

</script>
```
> 由于这中间存在不少异步回调操作，故可以另行将其整理起来。  

②
```
  const img = new Image()
  const reader = new FileReader()
  
  // 用来读取File对象或Blob对象，这里读取File
  reader.readAsDataURL(event.target.files[0]) 
     
  // result返回 DataURL 格式（Base64 编码）的字符串，代表图片内容   
  reader.onload = function(e){ 
   img.src = e.target.result
   // ③ ④ ⑤ ⑥ ⑦
  }
```

③
```
const { width: originWidth, height: originHeight } = img
// 最大尺寸限制
const maxWidth = 1000,maxHeight = 1000
// 需要压缩的目标尺寸
let targetWidth = originWidth, targetHeight = originHeight
// 等比例计算超过最大限制时缩放后的图片尺寸
if (originWidth > maxWidth || originHeight > maxHeight) {
  if (originWidth / originHeight > 1) {
   // 宽图片
   targetWidth = maxWidth
   targetHeight = Math.round(maxWidth * (originHeight / originWidth))
  } else {
   // 高图片
   targetHeight = maxHeight
   targetWidth = Math.round(maxHeight * (originWidth / originHeight))
  }
 }
```

④⑤⑥⑦
```
// ④ 创建画布并将img绘制到画布上
const canvas = document.createElement('canvas')

// ⑤ 实际上不需要的一步，用于查看效果
document.body.appendChild(canvas);

const context = canvas.getContext('2d')
 
// 设置宽高度为等同于要压缩图片的尺寸
canvas.width = targetWidth
canvas.height = targetHeight
 
context.clearRect(0, 0, targetWidth, targetHeight)
// 分别是元素、区域初始位置和区域宽高
// 将 img 绘制到画布上
context.drawImage(img, 0, 0, targetWidth, targetHeight)

 // ⑥ 转成blob文件
 canvas.toBlob(data => {
   ⑦ 首参即需要的blob，在这将其上传
   console.log(data);
 });
}
```

关于转成blob文件  
> 将canvas转换为文件的方法。  

参数 | 性质 | 说明 | 默认值
:-: | :-: | :- | :-:
callback | 必选 | 回调函数，首参为转化后的blob文件 | /
type | 可选 | **要转成**的图片类型 | `image/png`
encoderOptions | 可选 | 值在0与1之间，当格式为 `image/jpeg` 或 `image/webp` 时指定图片展示质量 | /

```
canvas.toBlob(callback, type, encoderOptions);
```











