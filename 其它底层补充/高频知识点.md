#### typeof类型判断
> `typeof` 对于原始类型来说，除了 null 都可以显示正确的类型。  
> 
> 可以考虑使用 `instanceof` [判断](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/常用方法速查.md#类型判断)对象的类型，其机制是通过原型链来判断的。原始类型则不可。  

```
let x = new Array('abc');  
let y = ['abc'];

document.write(typeof x);            // object
document.write(typeof y);            // object
document.write(x instanceof Array);  // true
document.write(y instanceof Array);  // true
document.write(x.constructor);       // f Arr() {}
document.write(y.constructor);       // f Arr() {}
```

```
let x = new String('abc');
let y = 'abc';

document.write(typeof x);             // object
document.write(typeof y);             // string
document.write(x instanceof String);  // true
document.write(y instanceof String);  // false
document.write(x.constructor);        // f Str() {}
document.write(y.constructor);        // f Str() {}
```

----

#### this
> 使用 `this` 指定对象后，没有该变量就是 `undefined`， 不会向上查找。

位置 | 指向
:-: | :-:
直接调用 foo | 不管 foo 函数在哪，`this` 一定是 window
obj.foo() | 谁调用了函数，谁就是 `this`
构造器函数 | 指向新对象

```
function foo() {
  console.log(this.a)
}
var a = 1
foo()               // 1

function bar() {
  let a = 233
  foo()
}
bar()               // 1

const obj = {
  a: 2,
  foo: foo
}
obj.foo()           // 2

const c = new foo()     // undefined
```

箭头函数
> 箭头函数中的 this 只取决包裹箭头函数的**第一个**普通函数**的 this**。

```
function a() {
  return () => {
    return () => {
      console.log(this)
    }
  }
}
a()()()    // Window
```

改变上下文  
> 对于这种改变上下文的方法，嵌套时，`this` 永远由第一次 bind 决定。
```
let a = {}
function fn () { console.log(this) }

fn.bind()(a)    // Window
fn.bind(a)()    // {}
```

![this](./img/this.png)

----

#### ==  

![wait](./img/wait.png)  

----

#### 解决var循环  
> 由于在异步前，全局 i 的值已经计算为 6，输出将全为 6。  
> 
> 可以将每轮循环的 i 值作为函数参数传入，也可以使用 `let` 运行在括号作用域。  

```
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}
```

----

#### 深浅拷贝   
> 浅拷贝：如果对象中的值为对象，则拷贝的是地址。即可以对原对象产生影响。  

浅拷贝  
```
let a = { text: 123 }

// 方式一  
let b = Object.assign({}, a)

// 方式二  
let b = { ...a }
```

深拷贝  
```
// 将对象转换为 JSON 后，再转换为对象
let b = JSON.parse(JSON.stringify(a))
```

该方法的局限性 | 结果  
:- | :-:
会忽略 undefined | 忽略
会忽略 symbol | 忽略
不能序列化函数 | 忽略
不能解决循环引用的对象 | 报错

----

#### 原型  
> 对象的 `__proto__ ` 属性指向原型， `__proto__` 将对象和原型连接起来组成了原型链。  

属性 | 所属 
:- | :-:
\_\_proto\_\_ | 对象
prototype  | [函数](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/第十章-函数.md#函数属性与方法)

#### var、let及const的区别

索引 | 说明  
:- | :-
① | var 存在提升，能在声明之前使用
② | let 和 const 在代码执行前会被 JS引擎解析，即**意味到该作用域有对应变量**，但无法使用
③ | 在全局作用域下使用 var 声明，变量会挂载在 window 上，其他两者不会
④ | let 和 const 作用基本一致，但是后者声明的变量不能再次赋值（包括引用值，即地址）  

#### 原型继承和Class继承  
> 其实在 JS 中并不存在类，class 只是语法糖，本质还是函数。  

组合继承  

项 | 方式  
:- | :-
继承属性 | `Parent.call(this, value1, ..)`
继承方法 | 父类实例作为原型
优势 | 可传参，引用属性不共享
缺点 | 调用了父类构造函数，子类原型上有多余属性，浪费内存
特征 | 父类为构造函数  

寄生组合继承

项 | 方式  
:- | :-
继承属性 | `Parent.call(this)`
继承方法 | 将父类的原型作为原型
优势 | 可传参，引用属性不共享
缺点 | /
特征 | 需将子类原型上的构造函数指向子类自身 

Class继承  
> class 实现继承的核心在于使用 `extends` 表明继承自哪个父类，并且在子类构造函数中必须调用 `super`，可以看成 `Parent.call(this, value)`。

#### 模块化  
> 早期使用立即执行函数实现模块化（解决命名冲突、污染全局变量的问题）。  
> 
> AMD 和 CMD 目前已很少使用。

优势  
- 解决命名冲突    
- 提供代码复用性  
- 提高代码可维护性  

CommonJS
> 最早是 Node 在使用，在 Webpack 中就能见到它。  

ES Module
> 与 CommonJS 不同，ES Module 导入的是拷贝值，不会因为导出值的改变而更新。  
> 
> 不支持动态导入。  

#### 简洁promise  

简化思路  

索引 | 步骤 | 小步骤
:- | :- | :-
① | 全局作用域 | 声明常量表示状态
② | MyPromise函数 | 保留作用域
③ | MyPromise函数 | 创建变量保存初始状态
④ | MyPromise函数 | 创建变量保存调用落定方法传入的参数
⑤ | MyPromise函数 | 创建变量（数组）保存 `then` 的回调
⑥ | MyPromise函数 | 创建落定方法，用于状态改变时执行相应所有回调
⑦ | MyPromise函数 | 将落定方法作为回调参数传出  
⑧ | then函数 | 保留作用域 
⑨ | then函数 | 判断参数类型，是否传入 
⑩ | then函数 | 等待状态时，往 `then` 的回调中推入函数
... | then函数 | 非等待状态时，执行函数  


#### 执行栈  
> 可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。  

#### call和apply   

实现myCall  

索引 | 步骤 | 小步骤
:- | :- | :-
① | 基本思路 | 函数原型上添加
② | 处理形参 | 只写一个形参（即首参），用于充当上下文
③ | 判断 | 判断 `this`，即调用者是否为为函数，不为则报错  
④ | 决定上下文 | 将形参（如存在）赋值为自身，否则 `window` 
⑤ | 添加方法 | 在形参上添加 `fn` 属性，赋值为 `this`，即调用者  
⑥ | 处理参数 | **处理参数**对象，将剩余参数作为参数并在上下文调用函数 
⑦ | 清除方法 | 移除形参上的该属性，返回结果  

实现myApply  
> 与 `call` 相比区别在于对参数的处理。  

实现myBind  
> `bind` 是函数上的方法，它会将调用者绑定到首参（作为上下文）上，并返回该方法。  
> 
> 可以使用 `new` 调用返回的方法。  
> 
> 该方法允许 `f.bind(obj, 1)(2)` 这种调用方式。

索引 | 步骤 | 小步骤
:- | :- | :-
① | 基本思路 | 函数原型上添加
② | 判断 | 判断 `this`，即调用者是否为为函数，不为则报错 
③ | 提供闭包变量 | 使用变量保存调用者和剩余参数  
④ | 返回函数 | 若为 `new` 调用，不需指定上下文
⑤ | 返回函数 | 否则，需要使用 `apply` 方法进行调用
⑤ | 返回函数 | 并指定上下文，结合之前的剩余参数和当前的参数列表

#### new  

在调用 new 的过程中会发生四件事情

- 新生成一个对象  
- 链接到原型  
- 绑定 `this`  
- 返回新对象  

自己实现new  
> 实现的 `create` 方法将接收首参作为构造函数，剩余参数用作传入构造函数的参数。

索引 | 步骤 | 小步骤
:- | :- | :-
① | 创建空对象 | 保存为变量
② | 获取构造函数 | 提取首参并保存为变量
③ | 指定原型 | 将空对象的原型赋值为构造函数的 `prototype` 属性 
④ | 获取调用结果 | 以剩余参数作参，执行构造函数并保存为变量
⑤ | 判断结果类型 | 为对象将结果返回
⑤ | 判断结果类型 | 否则将**空对象**返回  

通过 new 和通过**字面量**创建对象的区别。  

项 | 可读性 | 性能
:- | :- | :-
new | / | 需要通过作用域链一层层找到 Object
字面量 | 更好 | 不需要，更好

#### instanceof的原理  
> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype`。  

实现  

索引 | 步骤 | 说明
:- | :- | :-
① | 获取类型的原型 | 函数的 `prototype` 属性
② | 获得对象的原型 | 对象的 `__proto__` 属性  
③ | 循环判断两者相等性 | 直到对象原型为 `null`，返回 `false`  
④ | 循环判断两者相等性 | 相等则返回 `true`  
⑤ | 循环判断两者相等性 | 否则用对象原型的原型继续判断

#### 为什么0.1+0.2!=0.3  
> JS 采用双精度版本（64位），0.1 在二进制中表现为限循环的一些数字，采用的浮点数标准会裁剪掉部分数字丢失精度。  

为何输出0.1时能准确输出  
> 在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程。  

解决方法  
```
parseFloat((0.1 + 0.2).toFixed(10)) === 0.3 
```

#### 事件机制  

事件触发阶段  

顺序 | 步骤 | 触发事件
:- | :- | :-
① | window 往事件触发处传播 | 遇到的捕获事件
② | 事件触发处 | 不区分捕获、冒泡，按注册顺序执行程序
③ | 从事件触发处往 window 传播 | 遇到的冒泡事件

注册事件  
> 通常使用 `addEventListener` 注册事件，可以控制冒泡或捕获、仅调用一次等。  

事件对象方法 | 说明 
:- | :- 
stopPropagation | 阻止事件传播（冒泡或捕获）
stopImmediatePropagation | 阻止事件冒泡或捕获，并阻止该事件目标执行别的注册事件

事件代理  
> 如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上。  

- 节省内存  
- 不需要给子节点注销事件

#### 跨域  

什么是跨域？为什么浏览器要使用同源策略？  

- 浏览器出于安全考虑，有同源策略。也就是说，如果**协议、域名或者端口**有一个不同就是跨域，Ajax 请求（属于同源策略）会失败。

- 使用这种机制，主要是用来防止 CSRF 攻击的，即利用用户的登录态发起的恶意请求。  
> 用户登录了网站A，未退出，并在同一个浏览器打开了网站B。  
> 
> 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A。  
> 
> 浏览器在接收到这些攻击性代码后，根据网站 B 的请求，在用户不知情的情况下携带 Cookie 信息，以相应权限向网站 A 发出请求。

为何表单可以跨域？  

- 跨域请求会被发送，但通常会被浏览器拦截。表单并不会获取新的内容，所以可以发起跨域请求。

**解决跨域方案**  

JSON
> 利用 `<script>` 标签没有跨域限制的漏洞。通过 `<script>` 指向需要访问的地址并提供回调函数来接收数据。  

/ | 说明 
:- | :- 
优点 | 简单且兼容性不错
缺点 | 只限于 `get` 请求
特性 | ？需要服务器支持

CORS  
> 服务器段可以设置哪些域名可以访问资源。  
> 
> 对于一些复杂请求，由于会发送预检请求（确定服务端是否允许跨域请求），且它没有需要验证的 `Authorization` 字段，会报错。  

document.domain  
> 用于实现只要主域名相同就可以实现跨域。  

postMessage  
> 用于获取嵌入页面中的第三方页面数据。  

#### 存储  

特性 | cookie | localStorage | sessionStorage | indexDB
:- | :- | :- | :- | :- 
数据生命周期 | 一般由服务器生成，可设置过期时间 | 不清则在 | 页面关闭就清理 | 不清则在
数据存储大小 | 4K | 5M | 5M | 无限
与服务端通信 | 携带在头部中，影响请求性能 | 不参与 | 不参与 | 不参与

cookie  
> 已经不建议用于存储。使用时，还需要注意安全性。  

属性 | 作用
:- | :-
value | 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识
http-only | 不能通过 JS 访问 Cookie，减少 XSS 攻击
secure | 只能在协议为 HTTPS 的请求中携带
same-site | 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击

Service Worker  
> 运行在浏览器背后的独立线程，一般可以用来实现缓存功能。    
> 
> 因为涉及到请求拦截，所以必须使用 `HTTPS` 协议来保障安全。  

#### 浏览器缓存机制  
> 缓存可以说是性能优化中简单高效的一种优化方式了，它可以显著减少网络传输所带来的损耗。  

浏览器缓存  
> 对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。  

优化 | 方式
:- | :-
步骤一 | 直接使用缓存而不发起请求
步骤三 | 发起了请求，但后端存储的数据和前端一致，无需传回，可减少响应数据

**缓存位置**  
> 分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。  
> 
> 从其它地方或网络请求中获取的数据，浏览器都会显示是从 `Service Worker` 中获取的内容。  

顺序 | 步骤 | 缓存时间 | 说明
:- | :- | :- | :-
① | Service Worker | 持续性 | 可以控制缓存哪些文件、如何匹配缓存、如何读取缓存
② | Memory Cache | 短，随进程释放而释放 | 内存缓存。读取高效、容量小、刷新页面时很多数据缓存在这
③ | Disk Cache | 持续性 | 硬盘缓存。读取速度慢、容量大、覆盖面大、根据请求头判断缓存，直接使用或需重新请求的资源
④ | Push Cache | 短，随会话结束而释放| `HTTP/2` 中的内容，多个页面可以使用相同的缓存
⑤ | 网络请求 | / | 如果所有缓存都没有命中，就发起请求来获取资源

**缓存策略**  
> 通常浏览器缓存策略分为两种：强缓存和协商缓存，都是通过头部设置实现的。  

强缓存  
> 可以通过设置两种头部实现：Expires 和 Cache-Control。
> 
> 强缓存表示在缓存期间**不需要请求**，状态码为 200。

- Expires
  + 栗子：`Expires: Wed, 22 Oct 2018 08:41:00 GMT`  
  + 是 HTTP/1 的产物，表示资源会在设置时间后过期，需要再次请求。  
  + 受限于本地时间，若修改本地时间可能会造成缓存失效。  

- Cache-control  
  + 栗子：`Cache-control: max-age=30`  
  + 是 HTTP/1.1 的产物，优先级高于 Expires。  
  + 可以在请求头或者响应头中设置，并且可以组合使用多种指令。  
  + 如允许代理和客户端缓存、设置缓存失效时间。  

协商缓存  
> 如果缓存过期了，就**需要发起请求**验证资源是否有更新。协商缓存可以通过设置两种头部实现：Last-Modified 和 ETag
> 
> 当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回 304 状态码，并且更新浏览器缓存有效期。  

- Last-Modified 和 If-Modified-Since  
  + Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器。  
  + 询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码。  
  + 弊端
    - 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，导致返回相同资源。  
    - 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不返回正确资源。  

- ETag 和 If-None-Match  
  + ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，若有变动的话就将新的资源发送回来。
  + 并且 ETag 优先级比 Last-Modified 高。

:snowflake: 若没有设置缓存策略，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。  

**实际场景应用缓存策略**  

频繁变动的资源  
> 对于频繁变动的资源，首先需要使用 Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。  

代码文件  
> 这里特指除了 HTML 外的代码文件，因为 HTML 文件一般不缓存或者缓存时间很短。  

  一般来说，现在都会使用工具来打包代码，可以对文件名进行哈希处理，只有当代码修改后才会生成新的文件名。基于此，可以给代码文件设置缓存有效期一年 Cache-Control: max-age=31536000，这样只有当 HTML 文件中引入的文件名发生了改变才会去下载最新的代码文件，否则就一直使用缓存。  

### 浏览器渲染原理  

#### 渲染过程  

1. 浏览器接收到 HTML 文件并转换为 DOM 树  
> 当打开一个网页时，浏览器都会去请求对应的 HTML 文件。虽然平时我们写代码时都会分为 JS、CSS、HTML 文件，也就是字符串，但是计算机硬件是不理解这些字符串的。


顺序 | 步骤 | 说明
:- | :- | :-
① | 浏览器接收到字节数据后，将它转换为字符串 | 网络中传输的就是 `0`、`1` 这些字节数据
② | 字符串通过词法分析转换为标记 | 标记还是字符串，是构成代码的最小单位
③ | 标记会紧接着转换为 Node | / 
④ | 根据不同 Node 之间的联系构建为一颗 DOM 树 | / 

![标记](./img/标记.png)

![DOM树](./img/DOM树.png)

2. 将 CSS 文件转换为 CSSOM 树  
> 转换 CSS 到 CSSOM 树的过程和上一小节的过程是极其类似的。 

![CSSOM树](./img/CSSOM树.png)

在这一过程中，浏览器会确定下每一个节点的样式到底是什么，这是很消耗资源的。因为样式可以自行设置给某个节点，也可以通过**继承**获得。浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式。  

- 少写过于具体的 CSS 选择器   
- 对于 HTML，少添加无意义标签，保证层级扁平  

3. 生成渲染树  
> 生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。  
> 
> 渲染树只会包括**需要显示**的节点和这些节点的样式信息。  
> 
> 当浏览器生成渲染树以后，就会根据渲染树来进行布局（回流），然后调用 GPU 绘制，合成图层，显示在屏幕上。

#### 为什么操作DOM慢   
> DOM 属于渲染引擎，JS 属于 JS 引擎。当通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。  
> 
> 并且操作 DOM 可能还会带来重绘回流。  

如何插入数量级的DOM，实现页面不卡顿  
> 通过虚拟滚动（virtualized scroller）实现，原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。  
 
#### 什么情况阻塞渲染

1. 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。想渲染的快，应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。  
2. 浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。  
 
处理脚本  
 - 将 script 标签放在 body 标签底部。    
 - 给标签加上 `defer` 属性，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行。标签位置可任意。    
 - 对于没有任何依赖的 JS 文件可以加上 `async` 属性，表示 JS 文件下载和解析不会阻塞渲染。  

#### 重绘和回流  
> 重绘（Repaint）和回流（Reflow）会在设置节点样式时频繁出现，会影响性能。

索引 | 说明
:- | :- 
① | 重绘：当节点需要更改外观而不会影响布局的，比如改变颜色
② | 回流：布局或者几何属性需要改变
③ | **回流必定会发生重绘，重绘不一定会引发回流**
④ | 回流所需的成本比重绘高的多
⑤ | 改变父节点里的子节点很可能会导致父节点的一系列回流




