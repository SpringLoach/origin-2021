#### typeof类型判断
> `typeof` 对于原始类型来说，除了 null 都可以显示正确的类型。  
> 
> 可以考虑使用 `instanceof` [判断](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/常用方法速查.md#类型判断)对象的类型，其机制是通过原型链来判断的。原始类型则不可。  

```
let x = new Array('abc');  
let y = ['abc'];

document.write(typeof x);            // object
document.write(typeof y);            // object
document.write(x instanceof Array);  // true
document.write(y instanceof Array);  // true
document.write(x.constructor);       // f Arr() {}
document.write(y.constructor);       // f Arr() {}
```

```
let x = new String('abc');
let y = 'abc';

document.write(typeof x);             // object
document.write(typeof y);             // string
document.write(x instanceof String);  // true
document.write(y instanceof String);  // false
document.write(x.constructor);        // f Str() {}
document.write(y.constructor);        // f Str() {}
```

----

#### this
> 使用 `this` 指定对象后，没有该变量就是 `undefined`， 不会向上查找。

位置 | 指向
:-: | :-:
直接调用 foo | 不管 foo 函数在哪，`this` 一定是 window
obj.foo() | 谁调用了函数，谁就是 `this`
构造器函数 | 指向新对象

```
function foo() {
  console.log(this.a)
}
var a = 1
foo()               // 1

function bar() {
  let a = 233
  foo()
}
bar()               // 1

const obj = {
  a: 2,
  foo: foo
}
obj.foo()           // 2

const c = new foo()     // undefined
```

箭头函数
> 箭头函数中的 this 只取决包裹箭头函数的**第一个**普通函数**的 this**。

```
function a() {
  return () => {
    return () => {
      console.log(this)
    }
  }
}
a()()()    // Window
```

改变上下文  
> 对于这种改变上下文的方法，嵌套时，`this` 永远由第一次 bind 决定。
```
let a = {}
function fn () { console.log(this) }

fn.bind()(a)    // Window
fn.bind(a)()    // {}
```

![this](./img/this.png)

----

#### ==  

![wait](./img/wait.png)  

----

#### 解决var循环  
> 由于在异步前，全局 i 的值已经计算为 6，输出将全为 6。  
> 
> 可以将每轮循环的 i 值作为函数参数传入，也可以使用 `let` 运行在括号作用域。  

```
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}
```

----

#### 深浅拷贝   
> 浅拷贝：如果对象中的值为对象，则拷贝的是地址。即可以对原对象产生影响。  

浅拷贝  
```
let a = { text: 123 }

// 方式一  
let b = Object.assign({}, a)

// 方式二  
let b = { ...a }
```

深拷贝  
```
// 将对象转换为 JSON 后，再转换为对象
let b = JSON.parse(JSON.stringify(a))
```

该方法的局限性 | 结果  
:- | :-:
会忽略 undefined | 忽略
会忽略 symbol | 忽略
不能序列化函数 | 忽略
不能解决循环引用的对象 | 报错

----

#### 原型  
> 对象的 `__proto__ ` 属性指向原型， `__proto__` 将对象和原型连接起来组成了原型链。  

属性 | 所属 
:- | :-:
\_\_proto\_\_ | 对象
prototype  | [函数](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/第十章-函数.md#函数属性与方法)

#### var、let及const的区别

索引 | 说明  
:- | :-
① | var 存在提升，能在声明之前使用
② | let 和 const 在代码执行前会被 JS引擎解析，即**意味到该作用域有对应变量**，但无法使用
③ | 在全局作用域下使用 var 声明，变量会挂载在 window 上，其他两者不会
④ | let 和 const 作用基本一致，但是后者声明的变量不能再次赋值（包括引用值，即地址）  

#### 原型继承和Class继承  
> 其实在 JS 中并不存在类，class 只是语法糖，本质还是函数。  

组合继承  

项 | 方式  
:- | :-
继承属性 | `Parent.call(this, value1, ..)`
继承方法 | 父类实例作为原型
优势 | 可传参，引用属性不共享
缺点 | 调用了父类构造函数，子类原型上有多余属性，浪费内存
特征 | 父类为构造函数  

寄生组合继承

项 | 方式  
:- | :-
继承属性 | `Parent.call(this)`
继承方法 | 将父类的原型作为原型
优势 | 可传参，引用属性不共享
缺点 | /
特征 | 需将子类原型上的构造函数指向子类自身 

Class继承  
> class 实现继承的核心在于使用 `extends` 表明继承自哪个父类，并且在子类构造函数中必须调用 `super`，可以看成 `Parent.call(this, value)`。

#### 模块化  
> 早期使用立即执行函数实现模块化（解决命名冲突、污染全局变量的问题）。  
> 
> AMD 和 CMD 目前已很少使用。

优势  
- 解决命名冲突    
- 提供代码复用性  
- 提高代码可维护性  

CommonJS
> 最早是 Node 在使用，在 Webpack 中就能见到它。  

ES Module
> 与 CommonJS 不同，ES Module 导入的是拷贝值，不会因为导出值的改变而更新。  
> 
> 不支持动态导入。  

#### 简洁promise  

简化思路  

索引 | 步骤 | 小步骤
:- | :- | :-
① | 全局作用域 | 声明常量表示状态
② | MyPromise函数 | 保留作用域
③ | MyPromise函数 | 创建变量保存初始状态
④ | MyPromise函数 | 创建变量保存调用落定方法传入的参数
⑤ | MyPromise函数 | 创建变量（数组）保存 `then` 的回调
⑥ | MyPromise函数 | 创建落定方法，用于状态改变时执行相应所有回调
⑦ | MyPromise函数 | 将落定方法作为回调参数传出  
⑧ | then函数 | 保留作用域 
⑨ | then函数 | 判断参数类型，是否传入 
⑩ | then函数 | 等待状态时，往 `then` 的回调中推入函数
... | then函数 | 非等待状态时，执行函数  


#### 执行栈  
> 可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。  

#### call和apply   

实现myCall  

索引 | 步骤 | 小步骤
:- | :- | :-
① | 基本思路 | 函数原型上添加
② | 处理形参 | 只写一个形参（即首参），用于充当上下文
③ | 判断 | 判断 `this`，即调用者是否为为函数，不为则报错  
④ | 决定上下文 | 将形参（如存在）赋值为自身，否则 `window` 
⑤ | 添加方法 | 在形参上添加 `fn` 属性，赋值为 `this`，即调用者  
⑥ | 处理参数 | **处理参数**对象，将剩余参数作为参数并在上下文调用函数 
⑦ | 清除方法 | 移除形参上的该属性，返回结果  

实现myApply  
> 与 `call` 相比区别在于对参数的处理。  

实现myBind  
> `bind` 是函数上的方法，它会将调用者绑定到首参（作为上下文）上，并返回该方法。  
> 
> 可以使用 `new` 调用返回的方法。  
> 
> 该方法允许 `f.bind(obj, 1)(2)` 这种调用方式。

索引 | 步骤 | 小步骤
:- | :- | :-
① | 基本思路 | 函数原型上添加
② | 判断 | 判断 `this`，即调用者是否为为函数，不为则报错 
③ | 提供闭包变量 | 使用变量保存调用者和剩余参数  
④ | 返回函数 | 若为 `new` 调用，不需指定上下文
⑤ | 返回函数 | 否则，需要使用 `apply` 方法进行调用
⑤ | 返回函数 | 并指定上下文，结合之前的剩余参数和当前的参数列表

#### new  

在调用 new 的过程中会发生四件事情

- 新生成一个对象  
- 链接到原型  
- 绑定 `this`  
- 返回新对象  

自己实现new  
> 实现的 `create` 方法将接收首参作为构造函数，剩余参数用作传入构造函数的参数。

索引 | 步骤 | 小步骤
:- | :- | :-
① | 创建空对象 | 保存为变量
② | 获取构造函数 | 提取首参并保存为变量
③ | 指定原型 | 将空对象的原型赋值为构造函数的 `prototype` 属性 
④ | 获取调用结果 | 以剩余参数作参，执行构造函数并保存为变量
⑤ | 判断结果类型 | 为对象将结果返回
⑤ | 判断结果类型 | 否则将**空对象**返回  

通过 new 和通过**字面量**创建对象的区别。  

项 | 可读性 | 性能
:- | :- | :-
new | / | 需要通过作用域链一层层找到 Object
字面量 | 更好 | 不需要，更好

#### instanceof的原理  
> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype`。  

实现  

索引 | 步骤 | 说明
:- | :- | :-
① | 获取类型的原型 | 函数的 `prototype` 属性
② | 获得对象的原型 | 对象的 `__proto__` 属性  
③ | 循环判断两者相等性 | 直到对象原型为 `null`，返回 `false`  
④ | 循环判断两者相等性 | 相等则返回 `true`  
⑤ | 循环判断两者相等性 | 否则用对象原型的原型继续判断

#### 为什么0.1+0.2!=0.3  
> JS 采用双精度版本（64位），0.1 在二进制中表现为限循环的一些数字，采用的浮点数标准会裁剪掉部分数字丢失精度。  

为何输出0.1时能准确输出  
> 在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程。  

解决方法  
```
parseFloat((0.1 + 0.2).toFixed(10)) === 0.3 
```

#### 事件机制  

事件触发阶段  

顺序 | 步骤 | 触发事件
:- | :- | :-
① | window 往事件触发处传播 | 遇到的捕获事件
② | 事件触发处 | 不区分捕获、冒泡，按注册顺序执行程序
③ | 从事件触发处往 window 传播 | 遇到的冒泡事件

注册事件  
> 通常使用 `addEventListener` 注册事件，可以控制冒泡或捕获、仅调用一次等。  

事件对象方法 | 说明 
:- | :- 
stopPropagation | 阻止事件传播（冒泡或捕获）
stopImmediatePropagation | 阻止事件冒泡或捕获，并阻止该事件目标执行别的注册事件

事件代理  
> 如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上。  

- 节省内存  
- 不需要给子节点注销事件

#### 跨域  

什么是跨域？为什么浏览器要使用同源策略？  

- 浏览器出于安全考虑，有同源策略。也就是说，如果**协议、域名或者端口**有一个不同就是跨域，Ajax 请求（属于同源策略）会失败。

- 使用这种机制，主要是用来防止 CSRF 攻击的，即利用用户的登录态发起的恶意请求。  
> 用户登录了网站A，未退出，并在同一个浏览器打开了网站B。  
> 
> 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A。  
> 
> 浏览器在接收到这些攻击性代码后，根据网站 B 的请求，在用户不知情的情况下携带 Cookie 信息，以相应权限向网站 A 发出请求。

为何表单可以跨域？  

- 跨域请求会被发送，但通常会被浏览器拦截。表单并不会获取新的内容，所以可以发起跨域请求。

**解决跨域方案**  

JSON
> 利用 `<script>` 标签没有跨域限制的漏洞。通过 `<script>` 指向需要访问的地址并提供回调函数来接收数据。  

/ | 说明 
:- | :- 
优点 | 简单且兼容性不错
缺点 | 只限于 `get` 请求
特性 | ？需要服务器支持

CORS  
> 服务器段可以设置哪些域名可以访问资源。  
> 
> 对于一些复杂请求，由于会发送预检请求（确定服务端是否允许跨域请求），且它没有需要验证的 `Authorization` 字段，会报错。  

document.domain  
> 用于实现只要主域名相同就可以实现跨域。  

postMessage  
> 用于获取嵌入页面中的第三方页面数据。  

#### 存储  

特性 | cookie | localStorage | sessionStorage | indexDB
:- | :- | :- | :- | :- 
数据生命周期 | 一般由服务器生成，可设置过期时间 | 不清则在 | 页面关闭就清理 | 不清则在
数据存储大小 | 4K | 5M | 5M | 无限
与服务端通信 | 携带在头部中，影响请求性能 | 不参与 | 不参与 | 不参与

cookie  
> 已经不建议用于存储。使用时，还需要注意安全性。  

属性 | 作用
:- | :-
value | 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识
http-only | 不能通过 JS 访问 Cookie，减少 XSS 攻击
secure | 只能在协议为 HTTPS 的请求中携带
same-site | 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击

Service Worker  
> 运行在浏览器背后的独立线程，一般可以用来实现缓存功能。    
> 
> 因为涉及到请求拦截，所以必须使用 `HTTPS` 协议来保障安全。  

#### 浏览器缓存机制  
> 缓存可以说是性能优化中简单高效的一种优化方式了，它可以显著减少网络传输所带来的损耗。  

浏览器缓存  
> 对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。  

优化 | 方式
:- | :-
步骤一 | 直接使用缓存而不发起请求
步骤三 | 发起了请求，但后端存储的数据和前端一致，无需传回，可减少响应数据

**缓存位置**  
> 分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。  
> 
> 从其它地方或网络请求中获取的数据，浏览器都会显示是从 `Service Worker` 中获取的内容。  

顺序 | 步骤 | 缓存时间 | 说明
:- | :- | :- | :-
① | Service Worker | 持续性 | 可以控制缓存哪些文件、如何匹配缓存、如何读取缓存
② | Memory Cache | 短，随进程释放而释放 | 内存缓存。读取高效、容量小、刷新页面时很多数据缓存在这
③ | Disk Cache | 持续性 | 硬盘缓存。读取速度慢、容量大、覆盖面大、根据请求头判断缓存，直接使用或需重新请求的资源
④ | Push Cache | 短，随会话结束而释放| `HTTP/2` 中的内容，多个页面可以使用相同的缓存
⑤ | 网络请求 | / | 如果所有缓存都没有命中，就发起请求来获取资源

**缓存策略**  
> 通常浏览器缓存策略分为两种：强缓存和协商缓存，都是通过头部设置实现的。  

强缓存  
> 可以通过设置两种头部实现：Expires 和 Cache-Control。
> 
> 强缓存表示在缓存期间**不需要请求**，状态码为 200。

- Expires
  + 栗子：`Expires: Wed, 22 Oct 2018 08:41:00 GMT`  
  + 是 HTTP/1 的产物，表示资源会在设置时间后过期，需要再次请求。  
  + 受限于本地时间，若修改本地时间可能会造成缓存失效。  

- Cache-control  
  + 栗子：`Cache-control: max-age=30`  
  + 是 HTTP/1.1 的产物，优先级高于 Expires。  
  + 可以在请求头或者响应头中设置，并且可以组合使用多种指令。  
  + 如允许代理和客户端缓存、设置缓存失效时间。  

协商缓存  
> 如果缓存过期了，就**需要发起请求**验证资源是否有更新。协商缓存可以通过设置两种头部实现：Last-Modified 和 ETag
> 
> 当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回 304 状态码，并且更新浏览器缓存有效期。  

- Last-Modified 和 If-Modified-Since  
  + Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器。  
  + 询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码。  
  + 弊端
    - 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，导致返回相同资源。  
    - 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不返回正确资源。  

- ETag 和 If-None-Match  
  + ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，若有变动的话就将新的资源发送回来。
  + 并且 ETag 优先级比 Last-Modified 高。

:snowflake: 若没有设置缓存策略，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。  

**实际场景应用缓存策略**  

频繁变动的资源  
> 对于频繁变动的资源，首先需要使用 Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。  

代码文件  
> 这里特指除了 HTML 外的代码文件，因为 HTML 文件一般不缓存或者缓存时间很短。  

  一般来说，现在都会使用工具来打包代码，可以对文件名进行哈希处理，只有当代码修改后才会生成新的文件名。基于此，可以给代码文件设置缓存有效期一年 Cache-Control: max-age=31536000，这样只有当 HTML 文件中引入的文件名发生了改变才会去下载最新的代码文件，否则就一直使用缓存。  

### 浏览器渲染原理  

#### 渲染过程  

1. 浏览器接收到 HTML 文件并转换为 DOM 树  
> 当打开一个网页时，浏览器都会去请求对应的 HTML 文件。虽然平时我们写代码时都会分为 JS、CSS、HTML 文件，也就是字符串，但是计算机硬件是不理解这些字符串的。


顺序 | 步骤 | 说明
:- | :- | :-
① | 浏览器接收到字节数据后，将它转换为字符串 | 网络中传输的就是 `0`、`1` 这些字节数据
② | 字符串通过词法分析转换为标记 | 标记还是字符串，是构成代码的最小单位
③ | 标记会紧接着转换为 Node | / 
④ | 根据不同 Node 之间的联系构建为一颗 DOM 树 | / 

![标记](./img/标记.png)

![DOM树](./img/DOM树.png)

2. 将 CSS 文件转换为 CSSOM 树  
> 转换 CSS 到 CSSOM 树的过程和上一小节的过程是极其类似的。 

![CSSOM树](./img/CSSOM树.png)

在这一过程中，浏览器会确定下每一个节点的样式到底是什么，这是很消耗资源的。因为样式可以自行设置给某个节点，也可以通过**继承**获得。浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式。  

- 少写过于具体的 CSS 选择器   
- 对于 HTML，少添加无意义标签，保证层级扁平  

3. 生成渲染树  
> 生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。  
> 
> 渲染树只会包括**需要显示**的节点和这些节点的样式信息。  
> 
> 当浏览器生成渲染树以后，就会根据渲染树来进行布局（回流），然后调用 GPU 绘制，合成图层，显示在屏幕上。

#### 为什么操作DOM慢   
> DOM 属于渲染引擎，JS 属于 JS 引擎。当通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。  
> 
> 并且操作 DOM 可能还会带来重绘回流。  

如何插入数量级的DOM，实现页面不卡顿  
> 通过虚拟滚动（virtualized scroller）实现，原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。  
 
#### 什么情况阻塞渲染

1. 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。想渲染的快，应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。  
2. 浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。  
 
处理脚本  
 - 将 script 标签放在 body 标签底部。    
 - 给标签加上 `defer` 属性，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行。标签位置可任意。    
 - 对于没有任何依赖的 JS 文件可以加上 `async` 属性，表示 JS 文件下载和解析不会阻塞渲染。  

#### 重绘和回流  
> 重绘（Repaint）和回流（Reflow）会在设置节点样式时频繁出现，会**影响性能**。

索引 | 说明
:- | :- 
① | 重绘：当节点需要更改外观而不会影响布局的，比如改变颜色
② | 回流：布局或者几何属性需要改变
③ | **回流必定会发生重绘，重绘不一定会引发回流**
④ | 回流所需的成本比重绘高的多
⑤ | 改变父节点里的子节点很可能会导致父节点的一系列回流

**以下几个动作可能会导致性能问题：**

- 调整窗口大小
- 改变字体
- 添加或删除样式
- 文字改变
- 定位或者浮动
- 盒模型

:snowflake: 每次事件循环的微任务执行完毕后，会判断 document 是否需要更新，因为浏览器是 60Hz 的刷新率，每 16.6ms 才会更新一次。

#### 减少重绘和回流  

索引 | 操作 | 说明
:- | :- | :-  
① | 使用 `transform` 替代 `top` | 避免操作定位的位置属性
② | 使用 `visibility` 替换 `display: none` | 前者只引起重绘，后者引发回流
③ | 减少获取 `offsetTop` 属性 | 会导致回流
④ | 不使用 `table` 布局 | 小改动可能会造成 table 的重新布局
⑤ | 控制动画速度 | 速度越快，回流次数越多。可考虑 `requestAnimationFrame`
⑥ | 避免节点层级过多 | CSS 选择符从右往左匹配查找  
⑥ | 将频繁重绘/回流的节点设为图层 | 图层能够阻止该节点的渲染行为影响别的节点  

### 安全防范  

#### XSS  
> 简单点来说，就是攻击者想尽一切办法将可以执行的代码注入到网页中。  
> 
> 总体上分为两类：持久型和非持久型。  

- 持久型  
> 指攻击的代码（如用户评论）被服务端**写入数据库**中，这种攻击危害性很大，因为如果网站访问量很大的话，就会导致大量正常访问页面的用户都受到攻击。

- 非持久型  
> 一般通过修改 URL 参数的方式加入攻击代码，诱导用户访问链接从而进行攻击。  
> 
> 比如页面需要从 URL 中获取某些参数作为内容，而这些参数又被篡改。  
> 
> 对于这种攻击方式来说，如果用户使用 Chrome 这类浏览器的话，浏览器就能自动帮助用户防御攻击。但不能保证所有用户都使用这种浏览器。  

**防御方法 ** 

1. 转义字符  
> 用户的输入应该是永远不信任的。需要转义输入输出的内容，即对于引号、尖括号、斜杠进行转义。  
>
> 对于富文本来说，上面的方法不合适。这时可以考虑建立白名单来过滤标签等。  

2. CSP  
> 本质上就是建立白名单，开发者明确告诉浏览器**哪些外部资源**可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。

通常可以通过两种方式来开启 CSP：

- 设置 HTTP Header 中的 `Content-Security-Policy`  
- 设置 meta 标签的方式 `<meta http-equiv="Content-Security-Policy">`

#### CFRF  
> 跨站请求伪造。原理就是攻击者（非登录页）构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。  

**如何防御**

- Get 请求不对数据进行修改
- 不让第三方网站访问到用户 Cookie
- 阻止第三方网站请求接口
- 请求时附带验证信息，比如验证码或者 Toke

操作 | 说明
:- | :-  
SameSite | 对 Cookie 设置 `SameSite` 属性，表示 Cookie 不随着跨域请求发送，可减少许多 CSRF 的攻击。部分浏览器不兼容   
验证 Referer | 对于需要防范 CSRF 的请求，可以验证 `Referer` 来判断该请求是否为第三方网站发起的  
Token | 服务器下发一个随机 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效  

#### 点击劫持  
> 是一种**视觉欺骗**的攻击手段。攻击者**将需要攻击的网站**通过 `iframe` 嵌套的方式**嵌入**自己的网页中，并将 `iframe` 设置为透明，在页面中透出一个按钮诱导用户点击。  

**如何防御**

1. X-FRAME-OPTIONS  
> 这是一个相应头，可以设置页面不允许、仅相同域名下允许、或仅指定来源允许通过 `iframe` 的方式展现。  

2. JS防御  
> 对于某些远古浏览器来说，并不能支持上面的这种方式。  
> 
> 可以用 `self == top` 判断是否通过 iframe 的方式加载页面，如果是就将页面设为不展示并替换为主页面。  

### 从V8中看JS性能优化  

#### 测试性能工具  
> `Chrome` 提供了两个性能测试工具，可以在 `F12` 后通过展开找到。  

操作 | 说明
:- | :-  
Audits | 改为 Lighthouse。可以对性能、体验、SEO 打分，有详细评估和优化建议
Performance | 可以详细的看到每个时间段中浏览器在处理什么，哪个过程最消耗时间，便于了解性能瓶颈  
 
#### JS性能优化  
> JS 是编译型还是解释型语言其实并不固定。首先 JS 需要有引擎才能运行起来，无论是浏览器还是在 Node 中，这是解释型语言的特性。
> 
> 但是在 V8 引擎下，又引入了 TurboFan 编译器，他会在特定的情况下进行优化，将代码编译成执行效率更高的 Machine Code。  

顺序 | 说明 
:- | :- 
① | 在这一过程中，JS 代码首先会解析为抽象语法树（AST） 
② | 然后会通过解释器或者编译器转化为 Bytecode 或者 Machine Code
③ | Machine Code 的效率更高，计算固定类型（如Number）时编译
④ | 若传入的参数类型改变，那么 Machine Code 就会被 DeOptimized 为 Bytecode

索引 | 优化思路   
:- | :- 
① | 解析为 AST 时，代码越多，解析的过程也就耗费越长 
② | 尽可能避免声明嵌套函数，会造成函数的重复解析
③ | 计算时，尽量使用固定类型，即同一类型  
④ | 编译器还有个预解析的操作，对立即被调用的函数时多余的
⑤ | 可以将函数声明套上 `()` 解决  

### 性能优化  

#### 图片优化  
> 对于一张 100 * 100 像素的图片来说，图像上有 10000 个像素点，如果每个像素的值是 RGBA 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1 个字节，所以该图片大小大概为 39KB（10000 * 1 * 4 / 1024）。
> 
> 但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，可以通过减少每个像素的调色板来相应缩小图片的大小。  

索引 | 优化思路   
:- | :- 
① | 减少像素点
② | 减少每个像素点能够显示的颜色

#### 图片加载优化  

索引 | 优化思路 | 说明   
:- | :- | :- 
① | 使用 `CSS` 替代修饰类图片 | /
② | 对于移动端，屏幕小。通过 CDN 加载 | 可以计算出适配宽度，请求相应裁剪好的图片
③ | 小图使用 base64 格式 | 体积更大，但减少请求
④ | 图像精灵 | 又称雪碧图
⑤ | 选择正确的图片格式 | 见下  

类型 | 说明 
:- | :- 
WebP | 有更小的图片体积、肉眼识别无差异的图像质量，但兼容性并不好
PNG | 小图
SVG | 图标
JPEG | 照片

#### DNS预解析  
> 可以通过预解析的方式来预先获得域名所对应的 IP。  
> 
> 即浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在单击当前网页中的链接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验。  

```
<link rel="dns-prefetch" href="//blog.poetries.top">
```

#### [节流](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/实验项.md#节流函数)  
> 对于频繁触发的事件，希望减少程序的执行频率。  

#### 防抖  
> 对于有可能连续触发的事件，希望间隔时间内无连续发生才执行程序。  

#### 预加载  
> 在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。
> 
> 表示强制浏览器请求资源，并且不会阻塞 onload 事件。
> 
> 预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件**延后加载**，唯一缺点就是兼容性不好。

```
<link rel="preload" href="http://blog.poetries.top">
```

#### 预渲染  
> 可以通过预渲染将下载的文件预先在后台渲染，提高页面的加载速度。    
> 
> 要确保该页面大概率会被用户在之后打开，否则就是白白浪费资源去渲染。  

```
<link rel="prerender" href="http://blog.poetries.top">
```

#### 懒执行
> 将某些逻辑延迟到使用时再计算。可用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。

#### 懒加载  
> 将不关键的资源延后加载。  
> 
> 如使用图片占位符、进入可视区域才开始播放视频等。

#### CDN  
> CDN的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房**迅速加载资源**。
>
> 可以将静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有**并发请求上限**，可以考虑使用多个 CDN 域名。
>
> 并且对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie，平白消耗流量。

### Webpack性能优化  

#### 减少Webpack打包时间  

1. 优化 Loader
> 对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低。

索引 | 优化思路 | 说明   
:- | :- | :- 
① | 排除 `node_modules` | 其中代码都编译过，没必要再处理
② | 将 Babel 编译过的文件缓存起来| 下次只需要编译更改过的代码文件

2. HappyPack  
> 由于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的。  
> 
> `HappyPack` 可以将 Loader 的同步执行转换为并行的（分解成多个子进程并发执行），这样就能充分利用系统资源来加快打包效率了。  

4. 代码压缩  
> 在 Webpack3 中，一般使用 `UglifyJS` 来压缩代码，这是单线程运行的，为了加快效率，可以使用 `webpack-parallel-uglify-plugin` 来并行运行 `UglifyJS`，从而提高效率。  
> 
> 在 Webpack4 中，只需要将 `mode` 设置为 `production` 就默认开启以上功能。 

5. 一些小的优化点    

索引 | 优化思路 | 说明   
:- | :- | :- 
resolve.extensions | 尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面 | 默认查找顺序是 `['.js', '.json']`
resolve.alias | 通过别名的方式来映射路径，让 Webpack 更快找到路径 | \
module.noParse | 排除无其它依赖的文件，让 Webpack 不扫描 | \

#### 减少Webpack打包后的文件体积  

1. 按需加载  
> 通过[路由懒加载](https://github.com/SpringLoach/Vue/blob/main/learning/section2.md#路由懒加载)，能把不同路由对应的组件分割成不同的代码块（js文件），然后当路由被访问的时候才加载对应组件，这样就更加高效了。  

2. Scope Hoisting  
> 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去，减少代码量。  

```
// Webpack4
module.exports = {
  optimization: {
    concatenateModules: true
  }
}
```

3. Tree Shaking  
> 可以实现删除项目中未被引用的代码。  
> 
> 使用 Webpack 4 时，开启生产环境就会自动启动这个优化功能。  

#### [MVVM](https://github.com/SpringLoach/Vue/blob/main/learning/section1.md#vue中的mvvm)  

MVC
> 传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。
> 
> 缺点是控制器承担的责任太大了，随着项目愈加复杂，控制器中的代码会越来越臃肿，不利于维护。

#### 虚拟DOM  
> Virtual DOM。  
> 
> 相较于 DOM 来说，操作 JS 对象会**快很多**，并且可以通过 JS 来模拟 DOM

```
const ul = {
  tag: 'ul',
  props: {
    class: 'list'
  },
  children: {
    tag: 'li',
    children: '1'
  }
}

/* 上述代码对应 */

<ul class='list'>
  <li>1</li>
</ul>
```

局部跟新
> 难点在于如何判断新旧两个 JS 对象的最小差异并且实现局部更新 DOM

- 首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异
- 一旦节点有子元素，就去判断子元素是否有不同

> 在第一步算法中需要判断新旧节点的 tagName 是否相同，如果不相同的话就代表节点被替换了。如果没有更改 tagName 的话，就需要判断是否有子元素，有的话就进行第二步算法。
> 
> 在第二步算法中，需要判断列表中是否有节点被移除、加入或移动。
>
> 实际的算法中，通过 `key` 属性给节点加标志，用于判断是否是同一个节点。
> 
> 在判断以上差异的过程中，还需要判断节点的属性是否有变化等等。将差异记录。当对比完两棵树以后，就可以通过差异去局部更新 DOM，实现性能的最优化。

### 路由原理
> 本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新页面。目前前端使用的路由就只有两种实现方式。  

- Hash 模式
- History 模式

#### Hash模式  
> 当 `#` 后面的哈希值发生变化时，可以通过 `hashchange` 事件来监听到 URL 的变化，从而进行跳转页面。  
> 
> 相对来说更简单，并且兼容性也更好。  

```
window.addEventListener('hashchange', () => {
  // ... 具体逻辑
})
```

#### History模式  
> HTML5推出，主要使用 `history.pushState` 和 `history.replaceState` 改变 URL。
> 
> 改变 URL 同样不会引起页面的刷新，只会更新浏览器的历史记录。  

#### 两种模式对比  

Hash | History
:-: | :-:
只可以更改 `#` 后面的内容 |可以通过 API 设置任意的同源 URL
只能更改哈希值，也就是字符串 | 可以通过 API 添加任意类型的数据到历史记录中
无需后端配置，并且兼容性好 | 如果后台没有相关[配置](https://github.com/SpringLoach/Vue/blob/main/learning/实验项.md#为Histor模式配置中间件)，在刷新或直接访问子路径时会返回 `404`

#### Vue和React之间的区别

区别 
:-: 
Vue 的表单可以使用 v-model 这个语法糖支持双向绑定，相比于 React 来说开发上更加方便  
Vue 修改状态相比来说要简单许多，并且底层使用了依赖追踪，页面更新渲染已经是最优的了。React 需要手动优化这些问题  
React 需要使用 JSX，有上手成本，并且需要工具链支持。
Vue 使用了模板语法，相比于 JSX 来说没有那么灵活，但可以脱离工具链，通过直接编写 render 函数就能在浏览器中运行。

----

### Vue常考知识点  

#### 生命周期钩子函数  

事件 | Vue3 | 调用时机 | 说明
:-: | :-: | :-: | :-:
beforeCreate | / | 实例初始化后 | 获取不到 props、data 的数据
created | / | 实例创建后 | 可获取数据，但未挂载，组件不可见 
beforeMount | / | 挂载前 | /
mounted | / | 挂载后 | 不保证子组件也被挂载。
beforeUpdate | / | 数据更新前 | /
updated | / | 数据更新后 | 不会保证子组件也被重绘。
activated | / | 被 `keep-alive` 缓存的组件激活时 | /
deactivated | / | 被 `keep-alive` 缓存的组件停用时 | /
beforeDestroy | beforeUnmount | 实例销毁前 | 即组件卸载前。适合移除事件、定时器等等
destroyed | unmounted | 实例销毁后 | 指令被解绑，事件监听器被移除，子实例被销毁

:snowflake: 如果希望等到整个视图都渲染完毕，可在 `mounted` 内部使用 `vm.$nextTick` 

:snowflake: 如果希望等到整个视图都重绘完毕，可在 `updated` 内部使用 `vm.$nextTick`




