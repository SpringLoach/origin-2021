#### typeof类型判断
> `typeof` 对于原始类型来说，除了 null 都可以显示正确的类型。  
> 
> 可以考虑使用 `instanceof` [判断](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/常用方法速查.md#类型判断)对象的类型，其机制是通过原型链来判断的。原始类型则不可。  

```
let x = new Array('abc');  
let y = ['abc'];

document.write(typeof x);            // object
document.write(typeof y);            // object
document.write(x instanceof Array);  // true
document.write(y instanceof Array);  // true
document.write(x.constructor);       // f Arr() {}
document.write(y.constructor);       // f Arr() {}
```

```
let x = new String('abc');
let y = 'abc';

document.write(typeof x);             // object
document.write(typeof y);             // string
document.write(x instanceof String);  // true
document.write(y instanceof String);  // false
document.write(x.constructor);        // f Str() {}
document.write(y.constructor);        // f Str() {}
```

----

#### this
> 使用 `this` 指定对象后，没有该变量就是 `undefined`， 不会向上查找。

位置 | 指向
:-: | :-:
直接调用 foo | 不管 foo 函数在哪，`this` 一定是 window
obj.foo() | 谁调用了函数，谁就是 `this`
构造器函数 | 指向新对象

```
function foo() {
  console.log(this.a)
}
var a = 1
foo()               // 1

function bar() {
  let a = 233
  foo()
}
bar()               // 1

const obj = {
  a: 2,
  foo: foo
}
obj.foo()           // 2

const c = new foo()     // undefined
```

箭头函数
> 箭头函数中的 this 只取决包裹箭头函数的**第一个**普通函数**的 this**。

```
function a() {
  return () => {
    return () => {
      console.log(this)
    }
  }
}
a()()()    // Window
```

改变上下文  
> 对于这种改变上下文的方法，嵌套时，`this` 永远由第一次 bind 决定。
```
let a = {}
function fn () { console.log(this) }

fn.bind()(a)    // Window
fn.bind(a)()    // {}
```

![this](./img/this.png)

----

#### ==  

![wait](./img/wait.png)  

----

#### 解决var循环  
> 由于在异步前，全局 i 的值已经计算为 6，输出将全为 6。  
> 
> 可以将每轮循环的 i 值作为函数参数传入，也可以使用 `let` 运行在括号作用域。  

```
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}
```

----

#### 深浅拷贝   
> 浅拷贝：如果对象中的值为对象，则拷贝的是地址。即可以对原对象产生影响。  

浅拷贝  
```
let a = { text: 123 }

// 方式一  
let b = Object.assign({}, a)

// 方式二  
let b = { ...a }
```

深拷贝  
```
// 将对象转换为 JSON 后，再转换为对象
let b = JSON.parse(JSON.stringify(a))
```

该方法的局限性 | 结果  
:- | :-:
会忽略 undefined | 忽略
会忽略 symbol | 忽略
不能序列化函数 | 忽略
不能解决循环引用的对象 | 报错

----

#### 原型  
> 对象的 `__proto__ ` 属性指向原型， `__proto__` 将对象和原型连接起来组成了原型链。  

属性 | 所属 
:- | :-:
\_\_proto\_\_ | 对象
prototype  | [函数](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/第十章-函数.md#函数属性与方法)

#### var、let及const的区别

索引 | 说明  
:- | :-
① | var 存在提升，能在声明之前使用
② | let 和 const 在代码执行前会被 JS引擎解析，即**意味到该作用域有对应变量**，但无法使用
③ | 在全局作用域下使用 var 声明，变量会挂载在 window 上，其他两者不会
④ | let 和 const 作用基本一致，但是后者声明的变量不能再次赋值（包括引用值，即地址）  

#### 原型继承和Class继承  
> 其实在 JS 中并不存在类，class 只是语法糖，本质还是函数。  

组合继承  

项 | 方式  
:- | :-
继承属性 | `Parent.call(this, value1, ..)`
继承方法 | 父类实例作为原型
优势 | 可传参，引用属性不共享
缺点 | 调用了父类构造函数，子类原型上有多余属性，浪费内存
特征 | 父类为构造函数  

寄生组合继承

项 | 方式  
:- | :-
继承属性 | `Parent.call(this)`
继承方法 | 将父类的原型作为原型
优势 | 可传参，引用属性不共享
缺点 | /
特征 | 需将子类原型上的构造函数指向子类自身 

Class继承  
> class 实现继承的核心在于使用 `extends` 表明继承自哪个父类，并且在子类构造函数中必须调用 `super`，可以看成 `Parent.call(this, value)`。

#### 模块化  
> 早期使用立即执行函数实现模块化（解决命名冲突、污染全局变量的问题）。  
> 
> AMD 和 CMD 目前已很少使用。

优势  
- 解决命名冲突    
- 提供代码复用性  
- 提高代码可维护性  

CommonJS
> 最早是 Node 在使用，在 Webpack 中就能见到它。  

ES Module
> 与 CommonJS 不同，ES Module 导入的是拷贝值，不会因为导出值的改变而更新。  
> 
> 不支持动态导入。  

#### 简洁promise  

简化思路  

索引 | 步骤 | 小步骤
:- | :- | :-
① | 全局作用域 | 声明常量表示状态
② | MyPromise函数 | 保留作用域
③ | MyPromise函数 | 创建变量保存初始状态
④ | MyPromise函数 | 创建变量保存调用落定方法传入的参数
⑤ | MyPromise函数 | 创建变量（数组）保存 `then` 的回调
⑥ | MyPromise函数 | 创建落定方法，用于状态改变时执行相应所有回调
⑦ | MyPromise函数 | 将落定方法作为回调参数传出  
⑧ | then函数 | 保留作用域 
⑨ | then函数 | 判断参数类型，是否传入 
⑩ | then函数 | 等待状态时，往 `then` 的回调中推入函数
... | then函数 | 非等待状态时，执行函数  


#### 执行栈  
> 可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。  

#### call和apply   

实现myCall  

索引 | 步骤 | 小步骤
:- | :- | :-
① | 基本思路 | 函数原型上添加
② | 处理形参 | 只写一个形参（即首参），用于充当上下文
③ | 判断 | 判断 `this`，即调用者是否为为函数，不为则报错  
④ | 决定上下文 | 将形参（如存在）赋值为自身，否则 `window` 
⑤ | 添加方法 | 在形参上添加 `fn` 属性，赋值为 `this`，即调用者  
⑥ | 处理参数 | **处理参数**对象，将剩余参数作为参数并在上下文调用函数 
⑦ | 清除方法 | 移除形参上的该属性，返回结果  

实现myApply  
> 与 `call` 相比区别在于对参数的处理。  

实现myBind  
> `bind` 是函数上的方法，它会将调用者绑定到首参（作为上下文）上，并返回该方法。  
> 
> 可以使用 `new` 调用返回的方法。  
> 
> 该方法允许 `f.bind(obj, 1)(2)` 这种调用方式。

索引 | 步骤 | 小步骤
:- | :- | :-
① | 基本思路 | 函数原型上添加
② | 判断 | 判断 `this`，即调用者是否为为函数，不为则报错 
③ | 提供闭包变量 | 使用变量保存调用者和剩余参数  
④ | 返回函数 | 若为 `new` 调用，不需指定上下文
⑤ | 返回函数 | 否则，需要使用 `apply` 方法进行调用
⑤ | 返回函数 | 并指定上下文，结合之前的剩余参数和当前的参数列表

#### new  

在调用 new 的过程中会发生四件事情

- 新生成一个对象  
- 链接到原型  
- 绑定 `this`  
- 返回新对象  

自己实现new  
> 实现的 `create` 方法将接收首参作为构造函数，剩余参数用作传入构造函数的参数。

索引 | 步骤 | 小步骤
:- | :- | :-
① | 创建空对象 | 保存为变量
② | 获取构造函数 | 提取首参并保存为变量
③ | 指定原型 | 将空对象的原型赋值为构造函数的 `prototype` 属性 
④ | 获取调用结果 | 以剩余参数作参，执行构造函数并保存为变量
⑤ | 判断结果类型 | 为对象将结果返回
⑤ | 判断结果类型 | 否则将**空对象**返回  

通过 new 和通过**字面量**创建对象的区别。  

项 | 可读性 | 性能
:- | :- | :-
new | / | 需要通过作用域链一层层找到 Object
字面量 | 更好 | 不需要，更好

#### instanceof的原理  
> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype`。  

实现  

索引 | 步骤 | 说明
:- | :- | :-
① | 获取类型的原型 | 函数的 `prototype` 属性
② | 获得对象的原型 | 对象的 `__proto__` 属性  
③ | 循环判断两者相等性 | 直到对象原型为 `null`，返回 `false`  
④ | 循环判断两者相等性 | 相等则返回 `true`  
⑤ | 循环判断两者相等性 | 否则用对象原型的原型继续判断

#### 为什么0.1+0.2!=0.3  
> JS 采用双精度版本（64位），0.1 在二进制中表现为限循环的一些数字，采用的浮点数标准会裁剪掉部分数字丢失精度。  

为何输出0.1时能准确输出  
> 在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程。  

解决方法  
```
parseFloat((0.1 + 0.2).toFixed(10)) === 0.3 
```

#### 事件机制  

事件触发阶段  

顺序 | 步骤 | 触发事件
:- | :- | :-
① | window 往事件触发处传播 | 遇到的捕获事件
② | 事件触发处 | 不区分捕获、冒泡，按注册顺序执行程序
③ | 从事件触发处往 window 传播 | 遇到的冒泡事件

注册事件  
> 通常使用 `addEventListener` 注册事件，可以控制冒泡或捕获、仅调用一次等。  

事件对象方法 | 说明 
:- | :- 
stopPropagation | 阻止事件传播（冒泡或捕获）
stopImmediatePropagation | 阻止事件冒泡或捕获，并阻止该事件目标执行别的注册事件

事件代理  
> 如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上。  

- 节省内存  
- 不需要给子节点注销事件

#### 跨域  

什么是跨域？为什么浏览器要使用同源策略？  

- 浏览器出于安全考虑，有同源策略。也就是说，如果**协议、域名或者端口**有一个不同就是跨域，Ajax 请求（属于同源策略）会失败。

- 使用这种机制，主要是用来防止 CSRF 攻击的，即利用用户的登录态发起的恶意请求。  
> 用户登录了网站A，未退出，并在同一个浏览器打开了网站B。  
> 
> 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A。  
> 
> 浏览器在接收到这些攻击性代码后，根据网站 B 的请求，在用户不知情的情况下携带 Cookie 信息，以相应权限向网站 A 发出请求。

为何表单可以跨域？  

- 跨域请求会被发送，但通常会被浏览器拦截。表单并不会获取新的内容，所以可以发起跨域请求。

**解决跨域方案**  

JSON
> 利用 `<script>` 标签没有跨域限制的漏洞。通过 `<script>` 指向需要访问的地址并提供回调函数来接收数据。  

/ | 说明 
:- | :- 
优点 | 简单且兼容性不错
缺点 | 只限于 `get` 请求
特性 | ？需要服务器支持

CORS  
> 服务器段可以设置哪些域名可以访问资源。  
> 
> 对于一些复杂请求，由于会发送预检请求（确定服务端是否允许跨域请求），且它没有需要验证的 `Authorization` 字段，会报错。  

document.domain  
> 用于实现只要主域名相同就可以实现跨域。  

postMessage  
> 用于获取嵌入页面中的第三方页面数据。  

#### 存储  

特性 | cookie | localStorage | sessionStorage | indexDB
:- | :- | :- | :- | :- 
数据生命周期 | 一般由服务器生成，可设置过期时间 | 不清则在 | 页面关闭就清理 | 不清则在
数据存储大小 | 4K | 5M | 5M | 无限
与服务端通信 | 携带在头部中，影响请求性能 | 不参与 | 不参与 | 不参与

cookie  
> 已经不建议用于存储。使用时，还需要注意安全性。  

属性 | 作用
:- | :-
value | 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识
http-only | 不能通过 JS 访问 Cookie，减少 XSS 攻击
secure | 只能在协议为 HTTPS 的请求中携带
same-site | 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击

Service Worker  
> 运行在浏览器背后的独立线程，一般可以用来实现缓存功能。    
> 
> 因为涉及到请求拦截，所以必须使用 `HTTPS` 协议来保障安全。  

#### 浏览器缓存机制  
> 缓存可以说是性能优化中简单高效的一种优化方式了，它可以显著减少网络传输所带来的损耗。  

浏览器缓存  
> 对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。  

优化 | 方式
:- | :-
步骤一 | 直接使用缓存而不发起请求
步骤三 | 发起了请求，但后端存储的数据和前端一致，无需传回，可减少响应数据

**缓存位置**  
> 分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。  
> 
> 从其它地方或网络请求中获取的数据，浏览器都会显示是从 `Service Worker` 中获取的内容。  

顺序 | 步骤 | 缓存时间 | 说明
:- | :- | :- | :-
① | Service Worker | 持续性 | 可以控制缓存哪些文件、如何匹配缓存、如何读取缓存
② | Memory Cache | 短，随进程释放而释放 | 内存缓存。读取高效、容量小、刷新页面时很多数据缓存在这
③ | Disk Cache | 持续性 | 硬盘缓存。读取速度慢、容量大、覆盖面大、根据请求头判断缓存，直接使用或需重新请求的资源
④ | Push Cache | 短，随会话结束而释放| `HTTP/2` 中的内容，多个页面可以使用相同的缓存
⑤ | 网络请求 | / | 如果所有缓存都没有命中，就发起请求来获取资源






















 





