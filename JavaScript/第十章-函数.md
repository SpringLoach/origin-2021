- [第十章-函数](#第十章-函数)
  + [实例化函数对象](#实例化函数对象)
  + [箭头函数](#箭头函数)
  + [函数名](#函数名)
  + [理解参数](#理解参数)
  + [没有重载](#没有重载)
  + [默认参数值](#默认参数值)
    - 默认参数作用域与暂时性死区
  + [实参展开和形参合并](#实参展开和形参合并)
  + [函数声明与函数表达式](#函数声明与函数表达式)
  + [函数作为值](#函数作为值)
    - 返回另一个函数的执行结果
    - 返回另一个函数
  + [函数内部](#函数内部)
  + [函数属性与方法](#函数属性与方法)
  + [函数表达式](#函数表达式)
  + [尾调用优化](#尾调用优化)
    - 为调用优化的条件
  + [闭包](#闭包)
    - this对象
    - 内存泄漏
  + [立即调用的函数表达式](#立即调用的函数表达式)
    - ES6块级作用域的实现
  + [私有变量](#私有变量)
    - 模块模式
    - 模块增强模式


## 第十章-函数  
> 函数实际上是对象，而函数名是指向函数对象的指针，不一定与函数本身紧密绑定。  

#### 实例化函数对象
```
/* 函数声明 */
function sum(x, y) {return x + y;}

/* 函数表达式 */
let sum = function(x, y) {return x + y;};

/* 箭头函数 */
let sum = (x, y) => {return x + y};

/* 不建议的构造函数 */
let sum = new Function("x", "y", "return x + y");
```

----

#### 箭头函数  

序号 | 特征 
:-: | :-: 
Ⅰ | 有且只有一个参数时，可以不用括号
Ⅰ | 仅一参数，但使用默认参数时，括号不能省
Ⅱ | 省略大括号时，只能带一段代码，且隐性 `return`
Ⅲ | 不能使用 arguments、super、new.target
Ⅳ | 不能用作构造函数、没有 prototype 属性

----

#### 函数名  

```
function sum(x, y) {return x + y;}

/* 给变量赋值对象时，实际上复制的是指向地址的指针 */
let subSum = sum;

/* 解除 sum 对函数的引用 */
sum = null;
subSum(2, 3);  // 5
```

ES6 | 函数对象的 name 属性 
:-: | :-: 
① | 只读，保存函数标识符或空字符串
② | 对于获取、设置、bind()实例化的函数，有前缀

----

#### 理解参数  
> ECMAScript函数不声明命名参数也没关系，同时也不关心传参的个数及参数的类型。如果调用函数时没传对应的参数，它的值就是 `undefined`。  

函数内部的 `arguments` 对象是一个类数组对象，从中可以取得传入函数的每个参数，也可以访问 `arguments.length` 属性获取传参数量。  

序号 | 特征
:-: | :-: 
① | arguments 对象可以和命名参数一起使用
② | 修改 arguments 对象的值，将同步到对应的命名参数
③ | :grey_question: 修改命名参数的值，不会影响 arguments 对象对应的值
④ | arguments 对象在传参数量以外的修改不会反映到命名参数  
⑤ | 严格模式下，不可重写 arguments 对象，改值也不会同步到命名参数  

:snowflake: 箭头函数没有 `arguments` 对象，但可以通过包装函数提供给箭头函数。  

----

#### 没有重载 
> 重载：对于同一个函数，可拥有多个定义。接受参数的类型和数量不同，则（使用的）定义不同。  

----

#### 默认参数值  

ES6 | 默认参数值  
:-: | :-: 
① | 不传参或传 `undefined` 将使用默认参数值
② | 不会影响 `arguments` 对象，仍以调函时传值为准
② | 此时修改命名参数不会影响 `arguments` 对象

:snowflake: 函数x的默认参数可以是调用函数y后的返回值。函数x在定义时不会调用函数y，只有在调用函数x且未传相应参时，函数y才被调用。  

**#默认参数作用域与暂时性死区**

序号 | 特征  
:-: | :-: 
① | 定义多个默认参数相当于使用 let 关键字顺序声明，前参不可用后参赋值
② | 参数存在于自己的作用域，不能引用函数体的作用域

----

#### 实参展开和形参合并  
> [对象展开符](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/实验项.md#实参展开和形参合并)作为形参时，将剩余参数合并为数组；作为实参时，将可迭代对象转化为多个参数。  

用法 | 说明 
:-: | :-: 
命名参数 | 必须作为最后的参数
命名参数 | 将剩余参数合并为数组。无剩余参数时，得到空数组
传参 | 将可迭代对象转化为多个参数  

----

#### 函数声明与函数表达式  
> 函数声明会在代码执行前被读取并添加到执行上下文（作用域），包含于其中的函数定义也被添加到执行上下文。  

序号 | 特征  
:-: | :-: 
函数声明 | 提升，需要函数名称
函数表达式 | 不能提升  

----

#### 函数作为值  
> 可以在一个函数中返回另一个函数。  

**#返回另一个函数的执行结果**  
```
/* 将把第二个参数传递给 Fc 作为参数 */
function callFc(Fc, arg) {
  return Fc(arg);
} 

function add(n) {
  return n + 1;
}

callFc(add, 2);
```

**#返回另一个函数**
> 数组中包含多个对象，创建的函数将根据对象的属性进行排序。  
```
/* 内部函数可以从父级作用域拿到变量 propertyName */
function doComparison(propertyName) {
  return function(obj1, obj2) {
    let v1 = obj1[propertyName];
    let v2 = obj2[propertyName];
    
    if(v1 < v2) {
      return -1;
    } else if (v1 > v2) {
      return 1;
    } else {
      return 0;
    }
  };
} 

let x = [
  {name: 'Hong', age: 19},
  {name: 'Blue', age: 18}
]

/* 每次会传入两个数组元素作为参数 */
x.sort(doComparison('age'));
```

----

#### 函数内部  

类别 | 名称 | 说明 | 版本
:-: | :-: | :-: | :-: 
对象 | arguments | 传参列表，存在于 `function` 定义的函数 | ES5，非严格
属性 | arguments.callee | 指向 arguments 对象所在函数 | ES5，非严格
方法 | arguments.callee() | 调用自身所在函数。**递归**中调用可以与函数名解耦 | ES5，非严格
对象 | this | 标准函数：调用该方法的对象（执行上下文） | ES5
对象 | this | 箭头函数：定义该方法的对象（函数也是对象） | ES5
属性 | caller | `函数名.caller` 引用调用当前函数的函数 | ES5，非严格
属性 | new.target | 检测函数是否用 new 调用，返回 undefined / 被调用的构造函数 | ES6

----

#### 函数属性与方法  

类别 | 说明
:-: | :-: 
length | 函数定义的命名参数的个数
prototype | 保存引用类型所有实例方法；不可枚举  
apply() | 指定函数的执行上下文（this），传参
[call()](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/常用方法速查.md#call和apply) | 指定函数的执行上下文，传参
bind() | 返回函数，其中的 this 指向参数对象
toString() | 返回函数的代码，应只在调试中使用
toLocalString() | 同上
valueOf() | 返回函数本身  

----

#### 函数表达式  

名称 | 举栗 | 说明
:-: | :-: | :-: 
匿名函数 | `let sum = function(a, b) {...};` | `function` 关键字后面没有标识符 
匿名函数 | `function sum(){return function() {};}` | 被当作值使用的函数，一定是函数表达式   
命名函数表达式 | `const sum = (function f(a, b) {...});` | 可以在**递归**中调用自身，以避免赋值给其它变量所引起的问题   

----

#### 尾调用优化  
> ES6 新增的内存优化机制，这项优化非常适合“尾调用”，即外部函数的返回值是其某个内部函数的返回值。  

```
function outer() {
  return inner();  // 尾调用
}
```
由于引擎发现函数的逻辑允许基于尾调用将其销毁，此时无论多少层嵌套函数，都只有一个栈帧。  

**#为调用优化的条件**  

序号 | 说明
:-: | :-: 
① | 严格模式
② | 外部函数**直接**返回尾调用函数的调用
③ | 尾调用函数返回给外部函数的值不需要执行额外操作
④ | 尾调用函数不是引用了外部函数作用域中变量的闭包

----

#### 闭包  
> 闭包指的是那些引用了另一个函数作用域中变量的函数，通常在嵌套函数中实现。  

序号 | 原理
:-: | :-: 
① | 函数在执行时会创造作用域链
② | 用 arguments 和其它命名参数初始化自身的活动对象
③ | 作用域链上的第二个对象是其外部函数的活动对象
④ | 向外串包含函数，最终为全局的变量对象   

```
function father(n1) {
  let n2 = 3;
  return function() {
    return n1 + n2  // 引用父函数作用域的两个变量
  }
}

/* 父函数执行完毕后，其执行上下文的作用域链会销毁，
   但它的活动对象（由于匿名函数的引用）仍保留在内存中 */
let son = father(5);

let result = son();

/* 解除对匿名函数的引用，便可销毁父函数的活动对象 */
son = null;
```
:snowflake: 一般来说，变量对象在代码执行期间始终存在，而活动对象只在函数执行期间存在。  

**#this对象**  

内部函数 | 指向
:-: | :-: 
匿名函数 | 不再是执行函数的上下文，而会指向 window
箭头函数 | 仍为定义它的对象（函数）

**#内存泄漏**   
> 在旧版本的IE中，由于垃圾回收机制不同，把 HTML 元素保存在闭包的作用域，就相当于元素不能被销毁。  

```
function handle() {
  let el = document.getElementById('header');
  let id = element.id;
  
  element.onclick = () => console.log(id);
  
  /* 解除对 COM 对象的引用（使箭头函数引用不到它），销毁包含函数的活动对象 */
  element = null
}
```

----

#### 立即调用的函数表达式  
> 指立即调用的匿名函数。它类似于函数声明，但由于被包含在括号中，所以会被解释为函数表达式。

```
/* 可以模拟将变量限制在块级作用域中 */

(function() {
  // 块级作用域
})();
```

**#ES6块级作用域的实现**    
```
let divs = document.getElementsByTagName('div');

/* 这里不能用 var，也不能将 let 声明放到外面 */
for(let i = 0; i < 3; i++) {
  divs[i].addEventListener('click', function() {
    console.log(i);
  });
}
```

----

#### 私有变量  
> 任何定义在函数或块中的变量，都可以认为是私有的，均无法在外部访问。  

定义 | 说明
:-: | :-: 
私有变量 | 包括函数参数、局部变量，以及函数内部定义的其它函数
特权方法 | 能够访问函数私有变量的公共方法

在对象上有两种方式通过自定义类型创建特权方法  
1. 构造函数  
    - 把私有变量定义在构造函数中  
    - 创建能访问私有成员的特权方法（闭包）
    - 私有变量对于每个实例都是独一无二的  
    - 缺点是每个实例都会重新创建一遍新方法  

2. 静态私有变量  
    - 通过[立即调用的函数表达式](#立即调用的函数表达式)创建私有作用域  
    - 为了给外部访问到，使用全局声明构造函数
    - 将特权方法（闭包）定义到构造函数的原型上，能更好重用代码  
    - 缺点是每个实例都没有了自己的私有变量  

**#模块模式**  
> 将公共属性和方法保存在单例对象中。  

```
let single = function() {
  // 私有变量和私有函数  
  let num = 10;
  
  function verify() {
    return true
  }
  
  // 特权/共有方法和属性  
  return {
    public: true,
    getVerify() {return verify();}
  }
}();
```
:palm_tree: 单例对象：只有一个实例的对象，通过对象字面量创建。  

**#模块增强模式**  
> 适合的场景：单例对象需要是某个特定类型的实例，但又必须给它添加额外属性和方法。  

```
let single = function() {
  // 私有变量和私有函数
  let num = 10;
  
  function verify() {
    return true
  }
  
  // 创建特定类型的对象
  let obj = new anyType();
  
  // 特权/共有方法和属性 
  obj.public = true;
  obj.getVerify = function() {return verify();} 
    
  // 返回对象  
  return obj;
}();
```

## 第十一章-期约与异步函数  

### 异步编程  
> JavaScript使用的单线程事件循环模型。不想因为等待某个操作而阻塞线程执行时，就可以执行异步操作。  

**#以往的异步编程模式**  
> 需要消费异步操作的结果时，通常给异步操作提供一个回调，并使用异步返回的结果作为参数。  

----

### 期约  
> ES6新增的引用类型 Promise，可以通过 new 操作符来实例化。创建新期约时需要传入执行器函数作为参数。  

```
let p = new Promise(() => {});
```

#### 期约基础

**#期约对象的状态**  

私有状态 | 翻译 | 说明 | 落定状态接受值
:-: | :-: | :-: | :-: 
pending | 待定 | 尚未开始/正在执行 | 非落定状态
resolved | 兑现 | 成功 | 值
rejected | 拒绝 | 失败 | 理由

**#执行函数**  

功能 | 说明
:-: | :-: 
初始化期约的异步行为 | 执行函数时同步执行的  
控制状态的最终转变 | 传参 `resolve` 和 `reject`，在函数内调用以进入落定状态

:snowflake: 无论落定为哪种状态都是不可逆的。  

**#Promise.resolve()**  
> 通过调用 `Promise.resolve()` 静态方法，可以实例化一个解决的期约（直接为落定状态）。  

参数 | 说明 | 返回值
:-: | :-: | :-: 
期约 | 空包装，自身全等于该期约 | 该期约状态  
非期约值 | 转换为解决值 | `Promise <resolved>: 非期约值`  
不传参 | 解决值为 undefined | `Promise <resolved>: undefined`  

:snowflake: 传入方法的第一个参数，如果不是期约，便会被视作解决值。

**#Promise.reject()**  
> 与前面的方法类似。会抛出一个异步错误，故不能通过 try/catch 捕获，只能由拒绝处理程序捕获。    

参数 | 说明
:-: | :-: 
任何值 | 转化为拒绝的理由  
不传参 | 解决为 undefined 

:snowflake: 拒绝期约的错误不会抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理。  

#### 期约的实例方法  
> 这些方法可以访问异步操作返回的数据，并进行处理。  

**#then()**

参数 | 说明 | 更多
:-: | :-:  | :-: 
参数一 | 解决期约的处理程序 | 不想提供时，传入 null 
参数二 | 拒绝期约的处理程序 | 可选

:snowflake: 这个方法本身也返回一个期约。    

**#方法的返回值**    
> 方法会调用对应的处理程序，并通过 `Promise.resolve()` 包装处理程序中的返回值，返回新的期约。

相应的处理程序 | 处理程序中 | 包装
:-: | :-: | :-: 
无 | / | 返回 *上一个期约的状态*
√ | 无显性返回值 | undefined
√ | 有显性返回值 | 返回值 
√ | 返回期约 | 期约  
√ | 返回错误值 | 错误对象
√ | 抛出异常 | 返回 *拒绝的期约*

**#catch()**  
> 接收 onResovled 处理程序，返回新的期约。  

**#finally()**  
> 接收的处理程序在期约转换为解决或拒绝状态时都会执行，返回新的期约。  

处理程序 | 处理程序中 | 返回值
:-: | :-: | :-: 
无 | / | 返回 *上一个期约的状态*
√ | 无显性返回值 | 返回 *上一个期约的状态*
√ | 有显性返回值 | 返回 *上一个期约的状态*
√ | 返回待定期约 | 返回期约的状态
√ | 返回拒绝期约 | 返回期约的状态
√ | 抛出异常 | 返回 *拒绝的期约*  

**#非重入期约方法**   
> 当期约进入落定状态时，相关的处理程序会被排期（推进消息队列），并在当前线程上的同步代码执行完成后才开始执行。  

**#邻近处理程序的执行顺序**  
> 给同一个期约实例添加多个处理程序时，按添加顺序依次执行。  

**#传递解决值和拒绝理由**  

流程 | 方式 
:-: | :-: 
传递 | 作为执行函数中 `resolve()` 或 `reject()` 的第一个参数 
接收 | 作为处理程序的唯一参数  











