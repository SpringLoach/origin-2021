## 第十章-函数  
> 函数实际上是对象，而函数名是指向函数对象的指针，不一定与函数本身紧密绑定。  

#### 实例化函数对象
```
/* 函数声明 */
function sum(x, y) {return x + y;}

/* 函数表达式 */
let sum = function(x, y) {return x + y;};

/* 箭头函数 */
let sum = (x, y) => {return x + y};

/* 不建议的构造函数 */
let sum = new Function("x", "y", "return x + y");
```

#### 箭头函数  

序号 | 特征 
:-: | :-: 
Ⅰ | 有且只有一个参数时，可以不用括号
Ⅰ | 仅一参数，但使用默认参数时，括号不能省
Ⅱ | 省略大括号时，只能带一段代码，且隐性 `return`
Ⅲ | 不能使用 arguments、super、new.target
Ⅳ | 不能用作构造函数、没有 prototype 属性

#### 函数名  

```
function sum(x, y) {return x + y;}

/* 给变量赋值对象时，实际上复制的是指向地址的指针 */
let subSum = sum;

/* 解除 sum 对函数的引用 */
sum = null;
subSum(2, 3);  // 5
```

ES6 | 函数对象的 name 属性 
:-: | :-: 
① | 只读，保存函数标识符或空字符串
② | 对于获取、设置、bind()实例化的函数，有前缀

#### 理解参数  
> ECMAScript函数不声明命名参数也没关系，同时也不关心传参的个数及参数的类型。如果调用函数时没传对应的参数，它的值就是 `undefined`。  

函数内部的 `arguments` 对象是一个类数组对象，从中可以取得传入函数的每个参数，也可以访问 `arguments.length` 属性获取传参数量。  

序号 | 特征
:-: | :-: 
① | arguments 对象可以和命名参数一起使用
② | 修改 arguments 对象的值，将同步到对应的命名参数
③ | :grey_question: 修改命名参数的值，不会影响 arguments 对象对应的值
④ | arguments 对象在传参数量以外的修改不会反映到命名参数  
⑤ | 严格模式下，不可重写 arguments 对象，改值也不会同步到命名参数  

:snowflake: 箭头函数没有 `arguments` 对象，但可以通过包装函数提供给箭头函数。  

#### 没有重载 
> 重载：对于同一个函数，可拥有多个定义。接受参数的类型和数量不同，则（使用的）定义不同。  

#### 默认参数值  

ES6 | 默认参数值  
:-: | :-: 
① | 不传参或传 `undefined` 将使用默认参数值
② | 不会影响 `arguments` 对象，仍以调函时传值为准
② | 此时修改命名参数不会影响 `arguments` 对象

:snowflake: 函数x的默认参数可以是调用函数y后的返回值。函数x在定义时不会调用函数y，只有在调用函数x且未传相应参时，函数y才被调用。  

**#默认参数作用域与暂时性死区**

序号 | 特征  
:-: | :-: 
① | 定义多个默认参数相当于使用 let 关键字顺序声明，前参不可用后参赋值
② | 参数存在于自己的作用域，不能引用函数体的作用域

#### 实参展开和形参合并  
> [对象展开符](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/实验项.md#实参展开和形参合并)作为形参时，将剩余参数合并为数组；作为实参时，将可迭代对象转化为多个参数。  

用法 | 说明 
:-: | :-: 
命名参数 | 必须作为最后的参数
命名参数 | 将剩余参数合并为数组。无剩余参数时，得到空数组
传参 | 将可迭代对象转化为多个参数  

#### 函数声明与函数表达式  
> 函数声明会在代码执行前被读取并添加到执行上下文（作用域），包含于其中的函数定义也被添加到执行上下文。  

序号 | 特征  
:-: | :-: 
函数声明 | 提升
函数表达式 | 不能提升  

#### 函数作为值  
> 可以在一个函数中返回另一个函数。  

**#返回另一个函数的执行结果**  
```
/* 将把第二个参数传递给 Fc 作为参数 */
function callFc(Fc, arg) {
  return Fc(arg);
} 

function add(n) {
  return n + 1;
}

callFc(add, 2);
```

**#返回另一个函数**
> 数组中包含多个对象，创建的函数将根据对象的属性进行排序。  
```
/* 内部函数可以从父级作用域拿到 propertyName */
function doComparison(propertyName) {
  return function(obj1, obj2) {
    let v1 = obj1[propertyName];
    let v2 = obj2[propertyName];
    
    if(v1 < v2) {
      return -1;
    } else if (v1 > v2) {
      return 1;
    } else {
      return 0;
    }
  };
} 

let x = [
  {name: 'Hong', age: 19},
  {name: 'Blue', age: 18}
]

/* 每次会传入两个数组元素作为参数 */
x.sort(doComparison('age'));
```

#### 函数内部  

类别 | 名称 | 说明 | 版本
:-: | :-: | :-: | :-: 
对象 | arguments | 传参列表，存在于 `function` 定义的函数 | ES5
属性 | arguments.callee | 指向 arguments 对象所在函数 | ES5
方法 | arguments.callee() | 调用自身所在函数。递归中调用可以与函数名解耦 | ES5
对象 | this | 标准函数：调用该方法的对象（执行上下文） | ES5
对象 | this | 箭头函数：定义该方法的对象（函数也是对象） | ES5
属性 | caller | `函数名.caller` 引用调用当前函数的函数 | ES5
属性 | new.target | 检测函数是否用 new 调用，返回 undefined / 被调用的构造函数 | ES6

#### 函数属性与方法  

类别 | 说明
:-: | :-: 
length | 函数定义的命名参数的个数
prototype | 保存引用类型所有实例方法；不可枚举  
apply() | 指定函数的执行上下文（this），传参
[call()](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/常用方法速查.md#call和apply) | 指定函数的执行上下文，传参
bind() | 返回函数，其中的 this 指向参数对象
toString() | 返回函数的代码，应只在调试中使用
toLocalString() | 同上
valueOf() | 返回函数本身  

#### 函数表达式  

序号 | 特征  
:-: | :-: 
① | 又称为**匿名函数**，因为 `function` 关键字后面没有标识符 
② | 只要函数被当作值来使用（如 `return`），它就是一个函数表达式  








