## 第十三章-客户端检测

### 能力检测
> 使用一套简单的检测逻辑，测试浏览器是否支持某种特性，不在乎是什么浏览器。   
 
\- 先检测最常用的方式  
\- 必须检测切实需要的特性  

```
function getElement(id) {
    if (document.getElementById) {
        return document.getElementById(id);
    } else if (document.all) {    // IE5
        return document.all[id];
    } else {
        throw new Error("No way to retrieve element!");
    }
}
```

#### 1. 安全能力检测  
属性存在不代表就可以使用，进行能力检测时应该尽量使用 typeof 操作符（检测是否为函数）。

:frog:IE8及以前，DOM 对象被实现为 COM 对象，typeof 返回 `object` 而非 `function`。

#### 2. 基于能力检测进行浏览器分析

**检测特性** 

需要使用特定的浏览器能力，最好集中检测所有能力，保存在变量中的布尔值可以用在后面的条件语句中。  

**检测浏览器** 

可以根据对浏览器特性的检测结果与已知特性对比，确认用户使用的是什么浏览器。  

:frog:能力检测最适合用于决定下一步该怎么做，而不一定能够作为辨识浏览器的标志。

----

### 用户代理检测  
> 通过用户代理字符串确定浏览器。  

有时候知道是否基于某个渲染引擎比知道特定浏览器更重要。

**浏览器分析**   

用户代理字符串中包含浏览器等很多信息，但很多浏览器会 `伪装自己`，甚至有些浏览器提供方法 `篡改用户代理字符串`。

:frog:如果相信浏览器返回的用户代理字符串，那就可以用它来判断浏览器，如果怀疑脚本或浏览器篡改这个值，那最好用能力检测。在选择客户端检测方法时，首选是使用 `能力检测`。

**浏览器解析程序**   

推荐到 Github 上找。

----

### 软件与硬件检测（通过浏览器进行）

#### 识别浏览器与操作系统

还有浏览器开发商信息、显示器位深、设备旋转

#### 浏览器元数据

 API | 功能 
 :-: | :-: 
 Geolocation API | 让浏览器脚本感知当前设备的地理位置。
 Connection State 和 Network Information API | 跟踪网络连接状态并暴露相关信息。
 Battery Status API  | 访问设备电池及充电状态的信息。

#### 硬件  

访问处理器核心数（最大工作线程数量）、设备内存大小、最大触点数

## 第十四章-DOM
> 文档对象模型是 HTML 和 XML 文档的编程接口。

:frog: IE8及更低版本的 DOM 是通过 COM 对象实现的。故在这些版本的 IE 中，DOM 对象跟原生 Javascript 对象具有不用的行为和功能。

## 节点层级
> 任何 HTML 或 XML 文档都可以用 DOM 表示为一个由节点构成的层级机构。

----

### Node类型
> 在 Javascript 中，所有节点类型都继承 Node 类型，因此所有类型都共享相同的基本属性和方法。

#### 节点关系

 属性/方法 | 说明 
 :-: | :-: 
 nodeType | 表示该节点的类型
 nodeName 与 nodeValue | 属性的值取决于节点类型
 hasChildNodes() | 判断该节点有无子节点
 childNodes  | 包含一个 NodeList（此处为子节点列表）的实例
 firstChild 和 lastChild | 分别指向该节点的 childNodes 列表中的第一个和最后一个子节点
 PreviousSibling 和 nextSibling | 在同胞节点间导航
 parentNode | 指向父节点
 ownerDocument | 指向文档节点
 
> NodeList 是一个类数组对象，用于存储可以按位置存取的有序节点。可以访问它的某个（元素）节点、获取它的长度。也可以把 NodeList 对象转化为数组。

#### 操纵节点  
> 如果在**不支持子节点**的节点上调用这些方法，会导致抛出错误。

 方法 | 说明 | 参数
 :-: | :-: | :-: 
 appendChild() | 将节点添加/移动到 childNodes 列表的末尾 | 要插入的节点
 insertBefore() | 将节点添加/移动到 childNodes 列表的某个位置 | 要插入的节点，参照节点
 replaceChild() | 将节点替换到 childNodes 列表的某个位置 | 要插入的节点，要替换的节点
 removeChild()  | 将 childNodes 列表中的某个位置的节点删除| 要删除的节点

#### 其他方法

 方法 | 说明
 :-: | :-: 
 cloneNode() | 深复制（包括节点及其整个子 DOM 树）或仅复制节点
 normalize() | 检测该节点的后代，删除空文本节点，合并相邻的互为同胞关系的文本节点
 
```
<ul id="list">
    <li>a</li>
    <li>b</li>
    <li>n</li>
</ul>

let List = getElementById("list");
let List1 = List.cloneNode(true);     // childNodes.length 为 3 或 7
let List2 = List.cloneNode(false);    // childNodes.length 为 0
```
> 浏览器会为空格创建节点，IE9之前的版本则不会。

:bug: `cloneNode()` 方法不会复制添加到 DOM 节点的 Javascript 属性，比如事件处理程序。但是 IE 有这个 bug，所以推荐复制前先删除事件处理程序。

----

### Document类型  
> 文档对象（document）是 window 对象的属性，因此是一个全局对象。

#### 文档子节点

 属性 | 说明
 :-: | :-: 
 documentElement | 指向<html\>元素
 body | 指向<body\>元素
 doctype | 指向<!doctype\>元素

:frog:根据浏览器不同，可能会忽视出现在<html\>元素外面的注释（也是文档的子节点）


#### 文档信息  

 属性 | 说明
 :-: | :-: 
 title | 可以读写页面的标题
 URL | 读取完整的 URL
 domain | 可以读写域名
 referrer | 读取来源页面的 URL

#### 定位元素
> 这几个方法也可以在元素上调用，搜索范围会限制在当前元素之内。

 方法 | 说明
 :-: | :-: 
 getElementById() | 返回在文档中出现的**第一个** id 完全匹配的元素(区分大小写）
 getElementsByTagName() | 包含标签名匹配的元素列表（规定，但不区分大小写）
 getElementsByName() | 包含具有给定 name 属性的所有元素

#### HTMLCollection对象
> `getElementsByTagName()` 和 `getElementsByName()` 方法返回的都是 HTMLCollection 对象。
```
<img src="" name="sikadi">

let images = document.getElementsByTagName("img");

// 获取列表项的数量
let count = images.length;

// 通过索引获取列表项
let image1 = images[0];
let image1 = images.item(0);

// 通过 name 获取列表项
let image = images["sikadi"];
let image = images.namedItem("sikadi");
```

:frog:`getElementsByName()`方法最常用于单选按钮。

#### 特殊集合
> 这些集合也都是 HTMLCollection 的实例。

 属性 | 说明
 :-: | :-: 
 document.forms | 包含文档中所有<form\>元素
 document.images | 包含文档中所有<img\>元素
 document.anchors | 包含文档中所有带 name 属性的<a\>元素
 document.links | 包含文档中所有带href属性的<a\>元素

#### DOM兼容性检测  
> 目前这个方法已经被废弃。

```
let hasXmlDom = document.implementation.hasFeature("XML", "1.0");
```

#### 文档写入  

 属性 | 说明
 :-: | :-: 
 write() | 接受字符串参数，写入网页
 writeln() | 接受字符串参数，加上换行符后写入网页
 open() | :grey_question: 打开网页输出流
 close() | :grey_question: 关闭网页输出流

:frog:包含外部 JS 文件时，内容中不能直接出现字符串 "</script>"。  
:frog:在页面加载完之后再调用这个方法，则输出的内容会重写整个页面。

----

### Element类型   
> Element 表示 XML 或 HTML 元素，对外暴露出访问元素标签名、子节点和属性的能力。

 属性 | 说明
 :-: | :-: 
 nodeName | :exclamation: 获取元素的标签名
 tagName | :exclamation: 获取元素的标签名
 id | 读写 id 属性
 className | 读写class属性，即类
 title | 读写 title 属性
 lang | 读写元素内容的语言代码
 dir | 读写语言的书写方向
 
:frog:若不确定脚本在HTML文档还是XML文档中运行，最好将标签名转换为小写形式，以便比较。


#### 取得、设置属性    
 
 方法 | 说明
 :-: | :-: 
 getAttribute() | 取得公认或自定义属性值，但一般只用于取得**自定义属性**
 setAttribute() | 添加或替换属性，包括自定义属性
 removeAttribute() | 从元素中删除属性

> `getAttribute()`在访问 `style属性` 和 `事件属性` 时，返回的是字符串，故在编程时通常只使用 DOM 对象属性。

:frog:属性名不区分大小写。  
:frog:自定义属性应该前缀 data- 以方便验证，且在 DOM 对象上添加自定义属性会无效。

```
let x = document.getElementsByTagName("id")[0];
x.setAttribute("id","header");

/* DOM 对象属性 */
x.id = "header";
```  
:frog:元素所有公认的属性也会被添加到 DOM 对象的属性。  

#### attributes属性  
> 返回的对象包含实时属性集合，需要迭代元素上所有属性的时候有用。

 方法 | 说明
 :-: | :-: 
 getNamedItem(*name*) | 返回 nodeName 属性等于 name 的节点
 removeNamedItem(*name*) | 删除 nodeName 属性等于 name 的节点
 setNamedItem(*node*) | 向列表中添加 node 节点，以其 nodeName 为索引
 item(*pos*) | 返回索引位置 pos 处的节点
 
:frog:因为使用起来不方便，通常开发者更喜欢上一小节的方法，而不是这些。

#### 创建元素 
> 可以使用 `document.createElement()` 方法创建元素。

```
/* 先创建元素 */
let div = document.createElement("div");

/* 之后为其添加属性、甚至子元素 */
div.id = "footer";

/* 最后，通过操作节点添加到文档树中 */
document.body.appendChild(div);
```

#### 元素后代  

想要对所有元素后代执行某种操作时，代码间的空格可能会被视作 Text 节点，故通常需要先检测一下节点的 `nodeType`。 

----

### Text类型  
> `Text节点`由Text类型表示。  

 属性/方法 | 说明
 :-: | :-: 
 nodeValue| 读写节点包含的文本
 data | 读写节点包含的文本
 splitText() | 拆分文本节点
 略 | ... 

:frog:修改文本节点时，小于号、大于号或引号会被转义。
:frog:拆分文本节点最常用于从文本节点中提取数据的 DOM 解析技术。

#### 创建文本节点
> 创建文本节点后，要添加到元素上才能发挥作用。

`document.createTextNode()`，接受一个参数，为要插入节点的文本。

#### 合并同胞文本节点  

在相邻文本节点的父节点（Elements类型）上调用 `normalize()` 方法。

:frog:同胞文本节点只会出现在 DOM 脚本生成的文档树中。

----

### Comment类型  
> 拥有除 `splitText()`之外，Text节点所有的字符串操作方法。

 属性/方法 | 说明
 :-: | :-: 
 nodeValue | 注释的实际内容
 data | 注释的实际内容
 略 | ... 
 
----
### CDATASection类型
> 继承 Text 类型，因此拥有包括`splitText()`在内，Text节点所有的字符串操作方法。

CDATA区块只在 XML 文档中有效。

----

### DocumentType类型  
> 只有 name 属性是有用的，这个属性包含文档类型的名称。

```
<!DOCTYPE HTML PUBLIC ...>

alert(document.doctype.name);  // "HTML"
```

----

### DocumentFragment类型  
> 充当其他要被添加到文档的节点的仓库。  

可以通过 `appendChild()` 或 `insertBefore()` 方法将文档片段的内容添加到文档。届时，这个文档片段的所有子节点子节点会被添加到文档中相应的位置，文档片段本身永远不会被添加到文档树。

:star:使用文档片段可以避免多次渲染的问题。

----

### Attr类型  
> 属性节点尽管是节点，却不被认为是 DOM 文档树的一部分。

将属性作为节点来访问多数情况下并无必要。推荐使用 Element 类型中的取得、设置属性一节的方法。
 
## DOM编程

----

### 动态脚本
> 动态脚本就是在页面初始加载时不存在，之后又通过 DOM 添加的脚本。  

```
/* 加载外部文件 */
let script = document.createElement("script");
script.src = "foo.js";
document.body.appendChild(script);

/* 嵌入源代码 */
let script = document.createElement("script");
script.appendChild(document.createTextNode("function sayHi() {alert('hi');};));
document.body.appendChild(script);
```
:bug:对于 IE，不允许常规 DOM 访问<script\>的子节点，但<script\>元素上有一个 `text属性`，可以用来添加 Javascript 代码。

:whale2:跨浏览器向<script\>元素嵌入源代码的方式 P427

:frog:通过innerHTML属性创建的<script\>元素永远不会执行。

----

### 动态样式
> 页面初始加载时不存在，之后才添加到页面。

```
/* 加载外部文件 */
let link = document.createElement("link");
link.rel = "stylesheet";
link.type = "text/css";
link.href = "styles.css";
let head = document.getElemenetsByTagName("head")[0];
head.appendChild(link);

/* 嵌入 CSS 规则 */
let link = document.createElement("style");
style.type = "text/css";
style.appendChild(document.createTextNode("body{background-color:red}"));
let head = document.getElemenetsByTagName("head")[0];
head.appendChild(link);
```
:bug:对于 IE，不允许常规 DOM 访问<style\>的子节点，但<script\>元素上有一个 `styleSheet.cssText属性`，可以用来添加 CSS 样式。  
:bug:在同一个<style\>元素上设置多次`styleSheet.cssText属性`，或将属性值设置为空字符串，可能导致浏览器奔溃。

:whale2:跨浏览器向<style\>元素嵌入源代码的方式 P429

:frog: 最终都要把元素添加到<head\>元素上。

----

### 操作表格  
> 通过常规 DOM 编程创建<table\>元素，通常要涉及大量标签。

为了方便创建表格，给表格相关的元素添加了一些属性和方法。







