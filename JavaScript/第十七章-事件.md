# 第十七章 事件

[事件流](#事件流)

[事件处理程序](#事件处理程序)

[事件对象](#事件对象)

[事件类型](#事件类型)

[内存与性能](内存与性能)

[模拟事件](#模拟事件)


## 事件流  
> 事件流描述了页面接受事件的顺序。  

**事件冒泡：** 从最具体的元素(节点)开始触发，然后向上传播至没有那么具体的元素(最终到达文档)。  

**事件捕获：** 与事件冒泡的顺序相反。  

**DOM事件流：** 包含事件捕获、到达目标和事件冒泡。

## 事件处理程序  
> 事件处理程序的名字以 "on" 开头。

[HTML事件处理程序](#HTML事件处理程序)   

[DOM0事件处理程序](#DOM0事件处理程序)  

[DOM2事件处理程序](#DOM2事件处理程序)  

[IE事件处理程序](#IE事件处理程序)  

[跨浏览器事件处理程序](#跨浏览器事件处理程序)  

----

### HTML事件处理程序   
> 在 HTML 元素中，事件处理程序以 HTMl 属性的形式指定，属性名为事件处理程序的名字，值为 JS 代码。  
```
<input type="button" value="提交" onclick="console.log('你好！')"/>
```

#### 外部函数  
> 作为事件处理程序的代码可以访问全局作用域，showMessage()函数可以在<script>或外部文件中定义。  
```
<input type="button" value="提交" onclick="showMessage()"/>
```

#### 属性值
 序号 | 特性
 :-: | :-: 
 ① | 代码不能直接使用 HTML 语法字符，如双引号
 ② | 代码中的 this 将指向目标元素（自身）
 ③ | 大多数会封装在try/catch块中，以防止函数定义之前按钮被点击
 
 
#### 表单元素  
> 对于表单元素，可以直接访问同一表单中的其他成员。  
```
<form method="post">
    <input type="text" name="username" value="">
    <input type="button" value="Echo Username"
        onclick="console.log(username.value)">
</form>
```

----

### DOM0事件处理程序   
> 每个 DOM 元素都有事件处理程序属性，只要把这个属性赋值为一个函数即可，函数中的 this 引用元素本身。

```
let btn = document.getElementById("myBtn");
btn.onclick = function() {
    console.log(this.id);  // myBtn
}
```

----

### DOM2事件处理程序 
> 方法暴露在每个 DOM 元素上。

 函数 | 说明
 :-: | :-: 
 addEventListener() | 添加事件处理程序，可以同时为一个事件调用多次。
 removeEventListener() | 删除通过 `addEventListener()` 添加的事件处理程序，匿名函数无法移除。

```
let btn = document.getElementById("myBtn");
btn.addEventListener("click", () => {
    console.log(this.id);
}, false);
```
> 大多数情况下，事件处理程序会被添加到事件流的冒泡阶段，主要原因是跨浏览器兼容性好。  

----

### IE事件处理程序
> 与 DOM2 事件处理程序相似的方法：`attachEvent()` 和 `detachEvent()`
 
 特性 | addEventListener()  | attachEvent()
  :-: | :-: | :-: 
 第一参数 | "click" | "onclick"
 this 指向 | 元素本身:grey_question: | window
 添加处理程序的触发顺序 | 正向触发 | 方向触发
 
----
### 跨浏览器事件处理程序  

:whale2:跨浏览器事件处理程序·半成品版 P498
 
## 事件对象
> 在 DOM 中发生事件时创建。这个对象包含了一些基本信息，比如导致事件发生的元素、发生的事件类型，控制后续事件的行为等。  

[DOM事件对象](#DOM事件对象)   

[IE事件对象](#IE事件对象)   

[跨浏览器事件对象](#跨浏览器事件对象)

----
### DOM事件对象  

#### 参数传入
> event 对象是传给事件处理程序的唯一参数。  
```
let btn = document.getElementById("myBtn");
btn.onclick = function(event) {
    console.log(even.type);
};
btn.addEventListener("click", (event) => {
    console.log(even.type);
}, false);
```

#### HTML事件处理程序上的事件对象   
> 可以直接使用变量 event 引用事件对象，而不许传参。    
```
<input type="button" value="提交" onclick="console.log(event.type)">
```

:whale2: 使用 `type` 属性在一个处理程序处理多个事件 P500 

----  

### IE事件对象   
> 与 DOM 事件对象不同，IE事件对象不一定通过参数传入。  
```
var btn = document.getElementById("myBtn");
btn.onclick = function() {
    let event = window.event;
    console.log(even.type);
};

btn.attachEvent("click", (event) => {
    console.log(even.type);
});
```
> 在这两种方式中，`event` 都作为 window 对象的属性存在。  

#### HTML事件处理程序上的事件对象   
> 可以直接使用变量 event 引用事件对象，而不许传参。    
```
<input type="button" value="提交" onclick="console.log(event.type)">
```

----

### 跨浏览器事件对象  

:whale2:跨浏览器事件对象 P504

## 事件类型  

[用户界面事件](#用户界面事件)  

[鼠标和滚轮事件](#鼠标和滚轮事件)

[HTML5事件](#HTML5事件)

[设备事件](#设备事件)

[触摸及手势事件](#触摸及手势事件)

----

### 用户界面事件  
> 涉及与 BOM 交互的通用浏览事件。  

任何在 window 上发生的事件，实际开发中要尽量使用 Javascript 方式（`addEventListener()`），而不是在 <body> 元素上添加时间处理程序。  
 
`resize事件` 和 `scroll事件` 可能不断触发，相应的处理程序都应避免过多计算。

:whale2:给新建 图片/<script>/<link> 设置 `load事件` 处理程序 P507

---

### 鼠标和滚轮事件
> 获取客户端坐标、页面坐标、屏幕坐标、修饰键、相关元素等。  

:whale2:跨浏览器获取页面坐标、修饰键、相关元素 P513...

----

### HTML5事件
> 上下文菜单、提供阻止页面关闭的机会、往返缓存相关、散列值变化等事件。  

:whale2:自定义上下文菜单 P523  
:whale2:移除事件处理程序中的匿名函数 P526

----

### 设备事件
> 手机的翻转、朝向、移动事件。

----

### 触摸及手势事件

:whale2:追踪屏幕上的触摸轨迹 P532  
:whale2:追踪屏幕上两个触点的旋转角度和距离 P533

## 内存与性能
> 事件处理程序，即每个函数都是对象，都占用内存空间。其次，多次访问DOM会造成页面交互的延迟。  

[事件委托](#事件委托)

[删除事件处理程序](#删除事件处理程序)


----

### 事件委托  
只使用一个事件处理程序来管理**同种类型的事件**，通常将事件处理程序添加到祖先节点上去。

只要所有子元素都是元素x的后代，那它们的事件会向上冒泡，最终都会由这个元素x上的函数来处理。

----

### 删除事件处理程序  
最好在删除元素前，手动删除它的事件处理程序。

:grey_question:一般来说，最好在 `onunload事件` 处理程序中趁页面尚未卸载先删除所有事件处理程序。

## 模拟事件
> 可以通过 Javascript 模拟任意事件的发生。

[DOM事件模拟](#DOM事件模拟)

[IE事件模拟](#IE事件模拟)

----
### DOM事件模拟
通过在 `document.createEvent()` 方法中添加**参数**创建一个**对应类型**的 event 对象，在这个对象上有一个初始化自身的方法，最后在元素上调用 `dispatchEvent()` 方法触发事件。

:frog:DOM3Events 废弃了 `keypress事件`，但浏览器都有自己的办法模拟它。

### IE事件模拟  
> 接口与 DOM 方式不同。

# 第十八章 动画与Canvas图形
> 毋庸置疑，<canvas\>是 HTML5 最受欢迎的新特性。这个元素会占据一块页面区域，让 JavaScript 可以动态在上面绘制图片。

## 使用requestAnimationFrame  
> 早期定时动画基本上就是使用 setInterval() 来控制动画的执行，但方法本身不能保证时间精度，而浏览器本身也存在自身精度问题。

### 新方法    
> 为了解决这些问题，一个新的方法诞生了。    

 方法 | 说明  
  :-: | :-: 
 requestAnimationFrame() | 接受一个参数，参数为重绘屏幕前调用的函数，这个函数实际上也可以接受一个参数，表示下次重绘的时间
 cancelAnimationFrame() | 可以把上面方法返回的请求ID作为参数，来取消重绘任务

:whale2: 通过 requestAnimationFrame 实现动画循环  
:whale2: 通过 requestAnimationFrame 对事件监听器实行节流


## 基本的画布功能  
> `<canvas>元素` 至少要设置 width 和 height 属性，开始和结束标签之间的内容是后备数据。  

 方法 | 说明  
  :-: | :-: 
 getContext() | 在画布上绘制图形前，需要使用这个方法获取对绘图上下文的引用
 toDataURL() | 导出 <canvas\> 元素上的图像
 
:frog:使用这些方法前，确保浏览器支持 `<canvas>`

## 2D绘图上下文  
> 2D上下文的坐标原点(0,0)在 <canvas\> 元素的左上角。  

----
### 填充和描边

 属性 | 说明  
  :-: | :-: 
 fillStyle | 以指定样式(颜色、渐变或图像)填充形状
 strokeStyle | 为图形边界着色
> 与描边和填充相关的操作都会使用这两种样式，但可以再次修改。





