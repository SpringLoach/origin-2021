### Object  
> 很适合存储和再应用程序间交换数据。  

#### 实例化Object

```
/* 使用 new 操作符和 Object 构造函数 */
let obj = new Object();
obj.age = 29;

/* 使用对象字面量 */
let obj = {
  age: 29,
  4: true
}
// 数值属性会自动转换为字符串
// 旧版本中，最后的属性名加上逗号会报错
// 不会调用 Object 构造函数
```

#### 传入多个可选参数  
> 函数有大量可选参数时，最好的方式是对必选参数使用命名参数，再通过一个对象字面量来封装多个可选参数。  

```
anyFunction(some, any, {
  xx: "xx",
  yy: "yy"
})
```

#### 属性存取方式  

方式 | 说明 | 通过变量访问属性
:-: | :-: | :-:
点语法 | 首选方式 | × 
中括号 | 需要属性名的字符串形式 |  不需要引号

### Array  
> 与其他语言不同的是，数组中的每个槽位可以存储任意类型的数据。  

#### 实例化Array

```
/* 使用 Array 构造函数 */
let arr = new Array();

// 可以省略 new 操作符 
let arr = Array();

// 仅传一个数值时，设置数组长度 
let arr = new Array(2);

// 其它情况表示初始化数组 
let arr = new Array(2, 1);


/* 使用数组字面量 */
let arr = [];
// 不会调用 Array 构造函数
```

**#Array.from()**    
> 用于将类数组结构转换为数组示例。  

方式 | 说明 
:-: | :-: 
首参 | 可迭代的结构、有 `length` 属性和可索引元素的结构 
栗子 | 数组、字符串、集合、映射、arguments  

:snowflake: 如果参数为数组，将执行浅复制。  

其它的可选参数

方式 | 说明 
:-: | :-: 
参2 | 映射函数。可以直接增强新数组的值 
参3 | 指定映射函数中 this 的值，不适用于箭头函数  

**#Array.of()**    
> 将一组参数转化为数组示例。  

#### 数组空位  
> ES6新增的方法和迭代器在处理空位时与先前版本存在的方法行为不同。  

```
/* 包含三个元素，新版浏览器允许最后元素后跟, */
const arr = [,,,]
```

版本 | 说明 
:-: | :-: 
ES6新增 | 将空位当成存在的元素 `undefined` 
ES6以前 | 具体行为因方法而异，如 `map()` 会跳过空位  

:snowflake: 实践中要避免使用数组空位，真的需要时，用 `undefined` 值代替。  

#### 数组索引  

栗子 | 说明 
:-: | :-:
`arr[10] = 2;` | 数组索引大于长度时，其中夹着的元素为空值  
`arr.length = 5;` | 可以修改 `length` 来删除元素
`arr[arr.length] = 'last';` | 使用 `length` 可以方便地向数组末尾添加元素

#### 检测数组  
> 如果网页有多个框架，把数组传递后，由于执行上下文不同，其构造函数将有别于本地组数，此时 [instanceof](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/常用方法速查.md#类型判断) 不再适合，可以用 `Array.isArray()`。  

#### 迭代器方法  
> ES6添加了三个用于检索数组内容的方法：`keys`、`values` 和 [entries](https://github.com/SpringLoach/origin-2021/blob/happy-day/数据结构与算法/section1.md#数组的entries-方法)。  

#### 复制和填充方法  

方法 | 说明 
:-: | :-:
[fill()](https://github.com/SpringLoach/origin-2021/blob/happy-day/数据结构与算法/section1.md#使用fill方法) | 用静态值填充数组某部分
copyWidth() | 复制数组中一系列元素到自身的某处，不改[长度](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/常用方法速查.md#es6数组方法)

#### 转换方法  
> 有 `toLocaleString`、[toString](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/常用方法速查.md#valueof和tostring) 和 `valueof` 方法。  

:snowflake: `toLocaleString`、`toString`、`join` 和 `valueof` 会将数组中的 null 和 undefined 以空字符串表示。  

#### 栈方法  

类型 | 列举 
:-: | :-:
栈方法 | push、pop
队列方法 | push、shift、unshift
排序方法 | reserve、[sort](https://github.com/SpringLoach/origin-2021/blob/happy-day/数据结构与算法/section1.md#排序元素)
操作方法 | concat、slice、[splice](https://github.com/SpringLoach/origin-2021/blob/happy-day/数据结构与算法/section1.md#在任意位置添加或删除元素)
搜索和位置方法 | 严格相等（indexOf、lastIndexOf、ES7的includes）断言函数（find、findIndex）  
迭代方法 | every、filter、forEach、map、some，都不会改变调用它们的数组  
归并方法 | [reduce](https://github.com/SpringLoach/origin-2021/blob/happy-day/数据结构与算法/section1.md#解析reduce的用法)、reduceRight

:snowflake: 对于 `concat`，可以打平数组。 P150  
:snowflake: 断言函数和迭代方法都接受3个参数：元素、索引和数组本身。  

### 定型数组  
> 设计定型数组的目的是提高与 WebGL 等原生库交换二进制数据的效率。  

### Map  
> 能够真正地实现键/值存储机制，当然它的大多数特性都能通过 Object 类型实现。  

#### 基础API  

```
/* 创建空映射 */
const m = new Map();

/* 传入包含键/值对的可迭代对象来初始化映射 */
const m = ([
  ["k1", "v1"],
  ["k2", "v2"]
]);

/* 即使无键/值对，也会增加 size 属性 */
const m = ([
  []
])
```

实例方法/属性 | 参数 | 说明 
:-: | :-: | :-:
size | / | 获取映射中的键/值对的数量
get() | 键 | 键对应的值
set() | 键，值 | 添加键/值对。返回映射实例，可连缀使用
has() | 键 | 是否存在该键
delete() | 键 | 删除该键/值对
clear() | / | 清除所有键/值对

**#类型限制**  

内部 | Object | Map 
:-: | :-: | :-:
键 | 数值、字符串、符号 | 任何
值 | 任何 | 任何
插入顺序 | 不维护 | 维护

- 在映射中用作键和值的对象及其它 “集合” 类型，允许内容或属性被修改。  
- 意外：会将 NaN，（+0、-0） 视为同一个键。  

**#顺序与迭代**    
> 映射实例可以提供一个迭代器，能以插入顺序生产\[key, value\]形式的数组，可以通过 [entries()](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/常用方法速查.md#ES6数组方法) 方法取得该迭代器。  

```
/* 因为 entries() 是默认迭代器，所以可以直接对映射实例使用扩展操作 */
console.log([...m]); // [["k1", "v1"], ["k2", "v2"]]
```

键和值在迭代器遍历时是可以修改的，但这无法修改映射内部的引用。  

对应类型 | 修改后 
:-: | :-:
原始值 | 不会影响映射内部的该键或值
对象 | 修改对象的属性时，会影响映射内部的该键或值的属性  

:snowflake: 其它映射实例也能使用的方法：`forEach`、`keys`、`values`、`for...of`。  

#### 选择Object还是Map  
> 对于大多数 Web 开发任务来说，怎样选择这只是个人偏好问题。但考虑内存和性能，两者存在显著区别。  

能力 | 说明 
:-: | :-:
内存占用 | 给定固定大小的内存，Map 大约比 Object 多存储 50% 的键值对
插入性能 | 涉及大量插入操作时，Map 的性能更佳
查找速度 | 涉及大量查找操作时，某些情况 Object 更好
删除性能 | 涉及大量删除操作时，Map 的性能更佳




