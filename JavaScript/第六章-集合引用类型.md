### Object  
> 很适合存储和再应用程序间交换数据。  

#### 实例化Object

```
/* 使用 new 操作符和 Object 构造函数 */
let obj = new Object();
obj.age = 29;

/* 使用对象字面量 */
let obj = {
  age: 29,
  4: true
}
// 数值属性会自动转换为字符串
// 旧版本中，最后的属性名加上逗号会报错
// 不会调用 Object 构造函数
```

#### 传入多个可选参数  
> 函数有大量可选参数时，最好的方式是对必选参数使用命名参数，再通过一个对象字面量来封装多个可选参数。  

```
anyFunction(some, any, {
  xx: "xx",
  yy: "yy"
})
```

#### 属性存取方式  

方式 | 说明 | 通过变量访问属性
:-: | :-: | :-:
点语法 | 首选方式 | × 
中括号 | 需要属性名的字符串形式 |  不需要引号

### Array  
> 与其他语言不同的是，数组中的每个槽位可以存储任意类型的数据。  

#### 实例化Array

```
/* 使用 Array 构造函数 */
let arr = new Array();

// 可以省略 new 操作符 
let arr = Array();

// 仅传一个数值时，设置数组长度 
let arr = new Array(2);

// 其它情况表示初始化数组 
let arr = new Array(2, 1);


/* 使用数组字面量 */
let arr = [];
// 不会调用 Array 构造函数
```

**#Array.from()**    
> 用于将类数组结构转换为数组示例。  

方式 | 说明 
:-: | :-: 
首参 | 可迭代的结构、有 `length` 属性和可索引元素的结构 
栗子 | 数组、字符串、集合、映射、arguments  

:snowflake: 如果参数为数组，将执行浅复制。  

其它的可选参数

方式 | 说明 
:-: | :-: 
参2 | 映射函数。可以直接增强新数组的值 
参3 | 指定映射函数中 this 的值，不适用于箭头函数  

**#Array.of()**    
> 将一组参数转化为数组示例。  

#### 数组空位  
> ES6新增的方法和迭代器在处理空位时与先前版本存在的方法行为不同。  

```
/* 包含三个元素，新版浏览器允许最后元素后跟, */
const arr = [,,,]
```

版本 | 说明 
:-: | :-: 
ES6新增 | 将空位当成存在的元素 `undefined` 
ES6以前 | 具体行为因方法而异，如 `map()` 会跳过空位  

:snowflake: 实践中要避免使用数组空位，真的需要时，用 `undefined` 值代替。  

#### 数组索引  

栗子 | 说明 
:-: | :-:
`arr[10] = 2;` | 数组索引大于长度时，其中夹着的元素为空值  
`arr.length = 5;` | 可以修改 `length` 来删除元素
`arr[arr.length] = 'last';` | 使用 `length` 可以方便地向数组末尾添加元素

#### 检测数组  
> 如果网页有多个框架，把数组传递后，由于执行上下文不同，其构造函数将有别于本地组数，此时 [instanceof](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/常用方法速查.md#类型判断) 不再适合，可以用 `Array.isArray()`。  

#### 迭代器方法  
> ES6添加了三个用于检索数组内容的方法：`keys`、`values` 和 [entries](https://github.com/SpringLoach/origin-2021/blob/happy-day/数据结构与算法/section1.md#数组的entries-方法)。  

#### 复制和填充方法  

方法 | 说明 
:-: | :-:
[fill()](https://github.com/SpringLoach/origin-2021/blob/happy-day/数据结构与算法/section1.md#使用fill方法) | 用静态值填充数组某部分
copyWidth() | 复制数组中一系列元素到自身的某处，不改[长度](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/常用方法速查.md#es6数组方法)

#### 转换方法  
> 有 `toLocaleString`、[toString](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/常用方法速查.md#valueof和tostring) 和 `valueof` 方法。  

:snowflake: `toLocaleString`、`toString`、`join` 和 `valueof` 会将数组中的 null 和 undefined 以空字符串表示。  

#### 栈方法  

类型 | 列举 
:-: | :-:
栈方法 | push、pop
队列方法 | push、shift、unshift
排序方法 | reserve、[sort](https://github.com/SpringLoach/origin-2021/blob/happy-day/数据结构与算法/section1.md#排序元素)
操作方法 | concat、slice、[splice](https://github.com/SpringLoach/origin-2021/blob/happy-day/数据结构与算法/section1.md#在任意位置添加或删除元素)
搜索和位置方法 | 严格相等（indexOf、lastIndexOf、ES7的includes）断言函数（find、findIndex）  
迭代方法 | every、filter、forEach、map、some，都不会改变调用它们的数组  
归并方法 | [reduce](https://github.com/SpringLoach/origin-2021/blob/happy-day/数据结构与算法/section1.md#解析reduce的用法)、reduceRight

:snowflake: 对于 `concat`，可以打平数组。 P150  
:snowflake: 断言函数和迭代方法都接受3个参数：元素、索引和数组本身。  

### 定型数组  
> 设计定型数组的目的是提高与 WebGL 等原生库交换二进制数据的效率。  

### Map  
> 能够真正地实现键/值存储机制，当然它的大多数特性都能通过 Object 类型实现。  

#### 基础API  

```
/* 创建空映射 */
const m = new Map();

/* 传入包含键/值对数组的可迭代对象来初始化映射 */
const m = ([
  ["k1", "v1"],
  ["k2", "v2"]
]);

/* 即使无键/值对，也会增加 size 属性 */
const m = ([
  []
])
```

实例方法/属性 | 参数 | 说明 
:-: | :-: | :-:
size | / | 获取映射中的键/值对的数量
get() | 键 | 键对应的值/undefined
set() | 键，值 | 添加键/值对。返回映射实例，可连缀使用
has() | 键 | 是否存在该键
delete() | 键 | 删除该键/值对
clear() | / | 清除所有键/值对

**#类型限制**  

内部 | Object | Map | WeakMap
:-: | :-: | :-: | :-:
键 | 数值、字符串、符号 | 任何 | （继承自）对象
值 | 任何 | 任何 | 任何
插入顺序 | 不维护 | 维护 | 维护

- 在映射中用作键和值的对象及其它 “集合” 类型，允许内容或属性被修改。  
- 意外：会将 NaN，（+0、-0） 视为同一个键。  

**#顺序与迭代**    
> 映射实例可以提供一个迭代器，能以插入顺序生产\[key, value\]形式的数组，可以通过 [entries()](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/常用方法速查.md#ES6数组方法) 方法取得该迭代器。     

```
/* 因为 entries() 是默认迭代器，所以可以直接对映射实例使用扩展操作 */
console.log([...m]); // [["k1", "v1"], ["k2", "v2"]]
```

键和值在迭代器遍历时是可以修改的，但这无法修改映射内部的引用。  

对应类型 | 修改后 
:-: | :-:
原始值 | 不会影响映射内部的该键或值
对象 | 修改对象的属性时，会影响映射内部的该键或值的属性  

:snowflake: 其它映射实例也能使用的方法：`forEach`、`keys`、`values`、`for...of`。  

#### 选择Object还是Map  
> 对于大多数 Web 开发任务来说，怎样选择这只是个人偏好问题。但考虑内存和性能，两者存在显著区别。  

能力 | 说明 
:-: | :-:
内存占用 | 给定固定大小的内存，Map 大约比 Object 多存储 50% 的键值对
插入性能 | 涉及大量插入操作时，Map 的性能更佳
查找速度 | 涉及大量查找操作时，某些情况 Object 更好
删除性能 | 涉及大量删除操作时，Map 的性能更佳 
顺序迭代 | Object 不会维护插入顺序  

### WeakMap  
> 该集合类型提供了增强的键/值对存储机制。垃圾回收程序对待 “弱映射” 中键的方式是不同的。   

#### 基础API  

```
/* 创建空弱映射 */
const m = new WeakMap();

/* 传入包含键/值对数组的可迭代对象来初始化映射 */
// 键只能是 Object 或者继承自 Object 的类型
const k1 = {}, k2 = new Srting("hey");

const wm = ([
  [k1, "v1"],
  [k2, "v2"]
]);

// 只要有一个键无效就会抛出错误，导致整个初始化失败  
```

:snowflake: 实例方法/属性少了 `clear()` 和 `size`，其它与 Map 类型[相同](#基础API)。

#### 弱键  

弱映射 | 本身 | 何时垃圾回收
:-: | :-: | :-:
键 | 不属于正式的引用 | 没有其它地方保存着对键的引用
值 | 被键正式引用 | 键被回收 && 没有其它地方保存着对值的引用
 
```
const wm = new WeakMap();
const v = {a: {}}

/* 会被当作垃圾回收的目标 */
wm.set({}, 11);

/* 由 v 维护了该键的引用，不会被垃圾回收 */
wm.set(v.a, 22);
```
:herb: 可以利用延时的定时来模拟触发垃圾回收的场景。  

#### 不可迭代键  
> 因弱映射的键/值对随时可能被销毁，所以也没提供迭代键/值对的能力，也没有 `clear()` 这样一次销毁所有键/值对的方法。  

#### 使用弱映射  

**#私有变量**  
> 若将弱映射实例暴露在外，实现不了真正的私有；若使用立即执行函数将其隔离，会导致代码陷入 ES6 之前的闭包私有变量模式。  

**#DOM节点元数据**  
> 使用 WeakMap 实例保存关联元数据，不必担心引用问题。  

```
const wm = new WeakMap();

const loginButton = document.querySelector('#login');

/* 关联元数据 */
wm.set(loginButton, {disabled: true});

// 当节点从 DOM 树中被删除后，（其它地方也没引用该节点对象），弱映射不会阻止其被垃圾回收。  
```

### Set  

#### 基本API  

```
/* 使用 new  和 Set 构造函数创建空集合 */
const s = new Set();

/* 传入包含元素的可迭代对象来初始化集合 */
const s = new Set(["v1", "v2"]);

/* 自身也是可迭代对象，表示浅复制 */
const s2 = new Set(s);
```

实例方法/属性 | 参数 | 说明 | 返回值
:-: | :-: | :-: | :-:
size | / | 获取元素数量 | 数值
add() | 值 | 添加值 | 集合实例。可连缀使用
has() | 值 | 是否存在该键 | 布尔值
delete() | 值 | 删除该值 | 布尔值
clear() | / | 清除所有值 | undefined

:snowflake: 与 Map 类似，集合也使用 SameValueZero 操作，类似于 `===`，当添加相同值时，表示覆盖。  

#### 顺序与迭代2  
> 集合实例提供一个迭代器，能以插入顺序生成集合内容。可以通过 `values` 或 `keys` 取得。  

```
/* 因为 values() 是默认迭代器，所以可以直接对集合实例使用扩展操作 */
console.log([...s]); // ["v1", "v2"]
```

值在迭代器遍历时是可以修改的，但这无法修改映射内部的引用。  

对应类型 | 修改后 
:-: | :-:
原始值 | 不会影响映射内部的值
对象 | 修改对象的属性时，会影响集合内部该对象的属性  

**#类型限制**  

内部 | Object | Set | WeakSet
:-: | :-: | :-: | :-:
值 | 任何 | 任何 | （继承自）Object
插入顺序 | 不维护 | 维护 | 维护

#### 定义正式集合操作  
> 可以子类化 Set，添加集合操作。  

集合类型 | 实现逻辑 
:-: | :-:
并集 | 你有的加进来（可替换已有）
交集 | 公共的
差集 | 我有的且你没的
对称差集 | 减去公共的
笛卡尔积 | 我的每个子找到你的每个子 
幂集 | 用空集对首个元素拼组合，用所得组合往后拼组合

### WeakSet  
> Set 的子集，垃圾回收程序对待 “弱集合” 中值的方式有所不同。  

```
/* 实例化空的弱子集 */
const ws = new WeakSet();

/* 构造函数接收可迭代对象，其中的值只能是 Object 或继承自 Object */
const v1 = {}, v2 = new String("Hey");
const ws = new WeakSet([v1, v2]);

// 只要有一个值无效，整个初始化失败  
```

:snowflake: 实例方法/属性少了 `clear()` 和 `size`，其它与 Set 类型[相同](#基本API)。

#### 弱值  
> 弱集合不会维护其中的值的引用，若无其它地方引用值，会被垃圾回收。  

#### 不可迭代值  
> 类似于[不可迭代键](#不可迭代键)。  

#### 使用弱集合  
> 用处不大，可以新建一个集合保存对象，表示给对象打标签，而不必担心引用问题。  

### 迭代和扩展操作  

定义了默认迭代器的原生集合类型：  

- Array
- 所有定型数组
- Map
- Set

通性 | 项目
:-: | :-: 
兼容 |`for...of` [顺序循环](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/常用方法速查.md#es6数组方法)
兼容 |扩展操作符
配合...易操作 | Array.of()
配合...易操作 | Array.from()

```
/* 扩展操作符可以将可迭代对象展开为参数，轻松实现浅复制 */
let arr1 = [1, 2];
let arr2 = [...arr1];  // [1, 2]
arr1 === arr2  /// false

/* 也可以用于构造数组的部分元素 */
let arr3 = [0, ...arr1, 3]
```

## 迭代器与生成器  
> 迭代指按照顺序反复多次执行一段程序，通常会有明确的中止条件。  

### 理解迭代  
> 计数循环就是一种最简单的迭代。  

```
for (let i = 1; i <= 10; ++i) {console.log(i)}
```

也可以通过这样的方式迭代有序集合，弊端  
- 需先知道如何使用数据结构，如：`变量[索引]` 
- 遍历顺序并不一定就是递增索引  

### 迭代器模式  
> 把实现了正式的 Iterable 接口的结构称为 “可迭代对象”，可以通过迭代器 Iterator 消费。  


**#可迭代对象的特点**  

- 包含有限的元素  
- 具有无歧义的遍历顺序  

:palm_tree: 迭代器：按需创建的一次性对象。每个迭代器都会关联一个可迭代对象。

#### 可迭代协议  
> 要想实现 Iterable 接口，需要具有作为 “默认迭代器” 的属性，该属性以 `Symbol.iterator` 作为键，并引用一个迭代器工厂函数，调用该函数能返回一个新迭代器。   

**#实现了Iterable接口内置类型：**  

内置类型 
:-:
字符串
数组
映射
集合
[arguments对象](https://github.com/SpringLoach/origin-2021/blob/happy-day/JavaScript/第十章-函数.md#理解参数)
NodeList等DOM集合类型

:snowflake: 如果对象原型链上的父类实现了 Iterable 接口，那么对象自身也实现了。  

```
let str = 'str';  
str[Symbol.iterator]    // f values() { [native code] }
str[Symbol.iterator]()  // StringIterator {}
```

**#自动创建迭代器**  
> 这些原生语言结构会在后台调用可迭代对象的该工厂函数，从而创建一个迭代器。  

原生语言结构 | 说明
:-: | :-:
`for-of` 循环 | /
数组解构 | /
扩展操作符 | /
Array.from() | /
创建集合、映射 | /  
Promise.all() | 接收由期约组成的可迭代对象
Promise.race() | 同上
yield\*操作符 | 在生成器中使用  

#### 迭代器协议  
> 迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象。使用该对象的 `next()` 方法在可迭代对象中遍历数据，返回 IteratorResult 对象。  

IteratorResult | 说明 | 未完成 | 完成
:-: | :-: | :-: | :-:
done | 是否遍历完 | false | true
value | 当前值 | 值 | undefined

- 迭代器并不知道可迭代对象有多大  
- 不同迭代器的实例相互之间没有联系  
- 如果可迭代对象在迭代期间被修改，迭代器也会反映相应的变化  
- 迭代器会维护可迭代对象的引用，阻止垃圾回收  

#### 自定义迭代器  








