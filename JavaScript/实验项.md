#### 异步函数的执行顺序  

异步和同步函数  
> 无论如何，先执行同步  
```
function x() {
  setTimeout(() => {
    console.log("a")
  }, 0)
}
function y() {
    console.log("b")
}

x();
y();
// 先 b 后 a
```

两个异步函数
> 当第一个异步函数的延时比第二个异步函数**明显**大时，先执行第二个  
```
function x() {
  setTimeout(() => {
    console.log("a")
  }, 100)
}
function y() {
  setTimeout(() => {
    console.log("b")
  }, 0)
}
// 先 b 后 a
```

#### 防抖函数  

非立即执行版  
> 事件触发后，延迟时间内该事件都无发生时，才执行目标函数。  
```
<button onclick="de_toCall(2, 5)">commit</button>

function debounce(func, delay) {
  let timer = null;
  return function(...args) {
    if(timer) clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(this, args);  // this 指向执行环境（对象），这里指 Window 对象。若使用 DOM0 事件处理程序，指向接收此事件的 HTML 元素
    }, delay)
  }
}
function toCall(x, y) {
  console.log(x + y);
}
const de_toCall = debounce(toCall, 1000);  // Window 对象调用该方法  
```

立即执行版
> 如果未设置 timer，执行目标函数，且无论执行与否，重置定时器并对 timer 赋值。延迟后对 timer 赋空，允许执行目标函数。    
```
function debounce(func, delay) {
  let timer = null;
  return function(...args) {
      
    if(timer) clearTimeout(timer);  
    
    let ready = !timer; 
    timer = setTimeout(() => {
      timer = null;
    }, delay)
   
    if(ready) func.apply(this, args);
  }
}
```

组合版  
```
function debounce(func, delay, immediate) {
  let timer = null;
  return function(...args) {
      
    if(timer) clearTimeout(timer);  
    if (immediate) {
      let ready = !timer; 
      timer = setTimeout(() => {
        timer = null;
      }, delay)
      if(ready) func.apply(this, args);
    } else {
      timer = setTimeout(() => {
        func.apply(this, args);  
      }, delay)  
    }  
  }
}
```


#### 实参展开和形参合并  
> 对象展开符作为形参时，可以将剩余参数合并为数组；作为实参时，可以将数组转化为多个参数。  

作为形参
```
function a(x, ...args) {
 console.log(args)
}

a(1, 2, 3);  // [2, 3]
```

作为实参
```
function b(x, y) {
 console.log(x + y)
}

let num = [1, 2];

b(...num);  // 3
```
